<!-- doc/src/sgml/backup.sgml -->

<chapter id="backup">
<!--
 <title>Backup and Restore</title>
-->
 <title>バックアップとリストア</title>

 <indexterm zone="backup"><primary>backup</primary></indexterm>
 <indexterm zone="backup"><primary>バックアップ</primary></indexterm>

 <para>
<!--
  As with everything that contains valuable data, <productname>PostgreSQL</productname>
  databases should be backed up regularly. While the procedure is
  essentially simple, it is important to have a clear understanding of
  the underlying techniques and assumptions.
-->
貴重なデータを保持しているあらゆるもの同様、<productname>PostgreSQL</productname>データベースも定期的にバックアップされなければなりません。
バックアップの手順は基本的に簡単ですが、使用されている諸技術といくつかの前提条件を明確に理解しておくことが重要です。
 </para>

 <para>
<!--
  There are three fundamentally different approaches to backing up
  <productname>PostgreSQL</productname> data:
-->
<productname>PostgreSQL</productname>のデータをバックアップする場合、3つの異なる手法があります。
  <itemizedlist>
<!--
   <listitem><para><acronym>SQL</acronym> dump</para></listitem>
   <listitem><para>File system level backup</para></listitem>
   <listitem><para>Continuous archiving</para></listitem>
-->
   <listitem><para><acronym>SQL</acronym>によるダンプ</para></listitem>
   <listitem><para>ファイルシステムレベルのバックアップ</para></listitem>
   <listitem><para>継続的アーカイブ</para></listitem>
  </itemizedlist>
<!--
  Each has its own strengths and weaknesses; each is discussed in turn
  in the following sections.
-->
それぞれ長所と短所があります。
ひとつひとつ順を追って以下の節で説明します。
 </para>

 <sect1 id="backup-dump">
<!--
  <title><acronym>SQL</acronym> Dump</title>
-->
  <title><acronym>SQL</acronym>によるダンプ</title>

  <para>
<!--
   The idea behind this dump method is to generate a file with SQL
   commands that, when fed back to the server, will recreate the
   database in the same state as it was at the time of the dump.
   <productname>PostgreSQL</productname> provides the utility program
   <xref linkend="app-pgdump"/> for this purpose. The basic usage of this
   command is:
-->
このダンプ方法の背景にはSQLコマンドでファイルを生成し、そのファイルをサーバが再度読み込みを行った時に、ダンプした時点と同じ状態が再構築されるという意図があります。
この目的のため、<productname>PostgreSQL</productname>は<xref linkend="app-pgdump"/>ユーティリティプログラムを提供しています。
このコマンドの基本となる使い方は以下の通りです。
<synopsis>
pg_dump <replaceable class="parameter">dbname</replaceable> &gt; <replaceable class="parameter">dumpfile</replaceable>
</synopsis>
<!--
   As you see, <application>pg_dump</application> writes its result to the
   standard output. We will see below how this can be useful.
   While the above command creates a text file, <application>pg_dump</application>
   can create files in other formats that allow for parallelism and more
   fine-grained control of object restoration.
-->
見てわかる通り、<application>pg_dump</application>は結果を標準出力に書き出します。
これがどのように活用できるかをこれから説明します。
上記のコマンドはテキストファイルを作成しますが、<application>pg_dump</application>は並列処理を可能にしたり、オブジェクトのリストアをより細かく制御できる他のフォーマットでファイルを作れます。
  </para>

  <para>
<!--
   <application>pg_dump</application> is a regular <productname>PostgreSQL</productname>
   client application (albeit a particularly clever one). This means
   that you can perform this backup procedure from any remote host that has
   access to the database. But remember that <application>pg_dump</application>
   does not operate with special permissions. In particular, it must
   have read access to all tables that you want to back up, so in order
   to back up the entire database you almost always have to run it as a
   database superuser.  (If you do not have sufficient privileges to back up
   the entire database, you can still back up portions of the database to which
   you do have access using options such as
   <option>-n <replaceable>schema</replaceable></option>
   or <option>-t <replaceable>table</replaceable></option>.)
-->
<application>pg_dump</application>は、<productname>PostgreSQL</productname>の通常のクライアントアプリケーションです（その中でも特に優れた機能を発揮するものですが）。
ということは、データベースに接続可能なあらゆるリモートホストからこのバックアップ手順を実行できます。
しかし、<application>pg_dump</application>は特別な権限で実行される訳ではないことを忘れないでください。
特に、バックアップを行う全てのテーブルに対して読み取り権限が必要ですので、データベース全体のバックアップを実行する場合、ほとんど常にデータベースのスーパーユーザとして実行しなければなりません。
(もしデータベース全体のバックアップを取るのに十分な権限を持っていない場合には、<option>-n <replaceable>schema</replaceable></option>もしくは、<option>-t <replaceable>table</replaceable></option>のようなオプションを使って、データベースのアクセス権のある部分をバックアップできます。)
  </para>

  <para>
<!--
   To specify which database server <application>pg_dump</application> should
   contact, use the command line options <option>-h
   <replaceable>host</replaceable></option> and <option>-p <replaceable>port</replaceable></option>. The
   default host is the local host or whatever your
   <envar>PGHOST</envar> environment variable specifies. Similarly,
   the default port is indicated by the <envar>PGPORT</envar>
   environment variable or, failing that, by the compiled-in default.
   (Conveniently, the server will normally have the same compiled-in
   default.)
-->
<application>pg_dump</application>を行うデータベースサーバを特定するにはコマンドラインの<option>-h <replaceable>host</replaceable></option>オプションと<option>-p <replaceable>port</replaceable></option>オプションを使用します。
デフォルトのホストはローカルホスト、または<envar>PGHOST</envar>環境変数で指定したものです。
同様に、デフォルトのポートは<envar>PGPORT</envar>環境変数で指定されているか、うまく行かない場合にはコンパイル時の設定がデフォルトとなります（そこはうまくできていて、サーバは通常コンパイル時の設定をデフォルトとします）。
  </para>

  <para>
<!--
   Like any other <productname>PostgreSQL</productname> client application,
   <application>pg_dump</application> will by default connect with the database
   user name that is equal to the current operating system user name. To override
   this, either specify the <option>-U</option> option or set the
   environment variable <envar>PGUSER</envar>. Remember that
   <application>pg_dump</application> connections are subject to the normal
   client authentication mechanisms (which are described in <xref
   linkend="client-authentication"/>).
-->
他の<productname>PostgreSQL</productname>のクライアントアプリケーションのように、<application>pg_dump</application>はデフォルトでオペレーティングシステムの現在のユーザ名と同じデータベースユーザ名で接続します。
これを書き換えるには<option>-U</option>オプションを付けるか<envar>PGUSER</envar>環境変数を設定します。
<application>pg_dump</application>の接続は（<xref linkend="client-authentication"/>で説明されている）通常のクライアント認証方法によることを思い出してください。
  </para>

  <para>
<!--
   An important advantage of <application>pg_dump</application> over the other backup
   methods described later is that <application>pg_dump</application>'s output can
   generally be re-loaded into newer versions of <productname>PostgreSQL</productname>,
   whereas file-level backups and continuous archiving are both extremely
   server-version-specific.  <application>pg_dump</application> is also the only method
   that will work when transferring a database to a different machine
   architecture, such as going from a 32-bit to a 64-bit server.
-->
後で述べる他のバックアップ手法に対する<application>pg_dump</application>の重要な利点は、<application>pg_dump</application>の出力は一般に新しいバージョンの<productname>PostgreSQL</productname>に再ロードできるということです。
一方、ファイルレベルのバックアップと継続的アーカイブは両方とも非常にサーバ、バージョン依存です。
<application>pg_dump</application>は、32ビットから64ビットのサーバに移行するなどの異なるマシンアーキテクチャにデータベースを移す場合に上手くいく唯一の方法でもあります。
  </para>

  <para>
<!--
   Dumps created by <application>pg_dump</application> are internally consistent,
   meaning, the dump represents a snapshot of the database at the time
   <application>pg_dump</application> began running. <application>pg_dump</application> does not
   block other operations on the database while it is working.
   (Exceptions are those operations that need to operate with an
   exclusive lock, such as most forms of <command>ALTER TABLE</command>.)
-->
<application>pg_dump</application>で作成されたダンプは、内部的に整合性があります。
つまり、ダンプは<application>pg_dump</application>が開始された際のデータベースのスナップショットを示しています。
<application>pg_dump</application>の操作はデータベースに対する他の作業を妨げません（<command>ALTER TABLE</command>のほとんどの形態であるような排他的ロックが必要な作業は例外です）。
  </para>

  <sect2 id="backup-dump-restore">
<!--
   <title>Restoring the Dump</title>
-->
   <title>ダンプのリストア</title>

   <para>
<!--
    Text files created by <application>pg_dump</application> are intended to
    be read in by the <application>psql</application> program. The
    general command form to restore a dump is
-->
<application>pg_dump</application>で作成されたテキストファイルは<application>psql</application>プログラムで読み込まれることを意図しています。
以下に、ダンプをリストアする一般的なコマンドを示します。
<synopsis>
psql <replaceable class="parameter">dbname</replaceable> &lt; <replaceable class="parameter">dumpfile</replaceable>
</synopsis>
<!--
    where <replaceable class="parameter">dumpfile</replaceable> is the
    file output by the <application>pg_dump</application> command. The database <replaceable
    class="parameter">dbname</replaceable> will not be created by this
    command, so you must create it yourself from <literal>template0</literal>
    before executing <application>psql</application> (e.g., with
    <literal>createdb -T template0 <replaceable
    class="parameter">dbname</replaceable></literal>).  <application>psql</application>
    supports options similar to <application>pg_dump</application> for specifying
    the database server to connect to and the user name to use. See
    the <xref linkend="app-psql"/> reference page for more information.
    Non-text file dumps are restored using the <xref
    linkend="app-pgrestore"/> utility.
-->
ここで<replaceable class="parameter">dumpfile</replaceable>は<application>pg_dump</application>コマンドにより出力されたファイルです。
<replaceable class="parameter">dbname</replaceable>データベースはこのコマンドでは作成されません。
（例えば<literal>createdb -T template0 <replaceable class="parameter">dbname</replaceable></literal> のようにして）<application>psql</application>を実行する前に自分で<literal>template0</literal>から作成してください。
<application>psql</application>は<application>pg_dump</application>と似たような、接続データベースサーバと使用するユーザ名を指定するオプションに対応しています。
詳細については、<xref linkend="app-psql"/>のリファレンスページを参照してください。
テキスト形式ではないダンプファイルは<xref linkend="app-pgrestore"/> ユーティリティを使いリストアします。
   </para>

   <para>
<!--
    Before restoring an SQL dump, all the users who own objects or were
    granted permissions on objects in the dumped database must already
    exist. If they do not, the restore will fail to recreate the
    objects with the original ownership and/or permissions.
    (Sometimes this is what you want, but usually it is not.)
-->
SQLダンプのリストアを実行する前に、ダンプされたデータベース内のオブジェクトを所有するユーザやそのオブジェクト上に権限を与えられたユーザも存在しなければなりません。
存在していない場合、リストアはそのオブジェクトの元々の所有権や付与された権限を再作成することができません
（このようにしたい場合もあるでしょうが、通常そうではありません）。
   </para>

   <para>
<!--
    By default, the <application>psql</application> script will continue to
    execute after an SQL error is encountered. You might wish to run
    <application>psql</application> with
    the <literal>ON_ERROR_STOP</literal> variable set to alter that
    behavior and have <application>psql</application> exit with an
    exit status of 3 if an SQL error occurs:
-->
デフォルトで<application>psql</application>スクリプトは、SQLエラーが起きた後も実行を継続します。
<literal>ON_ERROR_STOP</literal>変数を設定して<application>psql</application>を実行することで、その動作を変更し、SQLエラーが起きた場合に<application>psql</application>が、終了ステータス3で終了するようにしたいと思うかもしれません。
<programlisting>
psql --set ON_ERROR_STOP=on <replaceable>dbname</replaceable> &lt; <replaceable>dumpfile</replaceable>
</programlisting>
<!--
    Either way, you will only have a partially restored database.
    Alternatively, you can specify that the whole dump should be
    restored as a single transaction, so the restore is either fully
    completed or fully rolled back. This mode can be specified by
    passing the <option>-1</option> or <option>&#45;-single-transaction</option>
    command-line options to <application>psql</application>. When using this
    mode, be aware that even a minor error can rollback a
    restore that has already run for many hours. However, that might
    still be preferable to manually cleaning up a complex database
    after a partially restored dump.
-->
どちらにしても、部分的にリストアされたデータベースにしかなりません。
他に、ダンプ全体を1つのトランザクションとしてリストアするように指定することができます。
こうすれば、リストアが完全に終わるか、完全にロールバックされるかのどちらかになります。
このモードは、<application>psql</application>のコマンドラインオプションに<option>-1</option>または<option>--single-transaction</option>を渡すことで指定できます。
このモードを使用する場合、数時間かけて実行していたリストアが軽微なエラーでロールバックしてしまうことに注意してください。
しかし、部分的にリストアされたダンプから手作業で複雑なデータベースを整理するよりまだましかもしれません。
   </para>

   <para>
<!--
    The ability of <application>pg_dump</application> and <application>psql</application> to
    write to or read from pipes makes it possible to dump a database
    directly from one server to another, for example:
-->
<application>pg_dump</application>と<application>psql</application>ではパイプから読み書きができるので、あるサーバから別のサーバへデータベースを直接ダンプできます。
以下に例を示します。
<programlisting>
pg_dump -h <replaceable>host1</replaceable> <replaceable>dbname</replaceable> | psql -h <replaceable>host2</replaceable> <replaceable>dbname</replaceable>
</programlisting>
   </para>

   <important>
    <para>
<!--
     The dumps produced by <application>pg_dump</application> are relative to
     <literal>template0</literal>. This means that any languages, procedures,
     etc. added via <literal>template1</literal> will also be dumped by
     <application>pg_dump</application>. As a result, when restoring, if you are
     using a customized <literal>template1</literal>, you must create the
     empty database from <literal>template0</literal>, as in the example
     above.
-->
<application>pg_dump</application>で作成されるダンプは<literal>template0</literal>と相対関係にあります。
つまり<literal>template1</literal>を経由して追加されたあらゆる言語、プロシージャなども<application>pg_dump</application>によりダンプされます。
その結果としてリストアする際に、カスタマイズされた<literal>template1</literal>を使用している場合は、上記の例のように、<literal>template0</literal>から空のデータベースを作成する必要があります。
    </para>
   </important>

   <para>
<!--
    After restoring a backup, it is wise to run <link
    linkend="sql-analyze"><command>ANALYZE</command></link> on each
    database so the query optimizer has useful statistics;
    see <xref linkend="vacuum-for-statistics"/>
    and <xref linkend="autovacuum"/> for more information.
    For more advice on how to load large amounts of data
    into <productname>PostgreSQL</productname> efficiently, refer to <xref
    linkend="populate"/>.
-->
バックアップをリストアした後、問い合わせオプティマイザが有用な統計情報を使用できるように、各データベースに対して<link linkend="sql-analyze"><command>ANALYZE</command></link>を実行することを勧めます。
より詳しくは、<xref linkend="vacuum-for-statistics"/> と <xref linkend="autovacuum"/>を参照してください。
効率的に大規模なデータを<productname>PostgreSQL</productname>にロードする方法に関するより多くの勧告については、<xref linkend="populate"/>を参照してください。
   </para>
  </sect2>

  <sect2 id="backup-dump-all">
<!--
   <title>Using <application>pg_dumpall</application></title>
-->
   <title><application>pg_dumpall</application>の使用</title>

   <para>
<!--
    <application>pg_dump</application> dumps only a single database at a time,
    and it does not dump information about roles or tablespaces
    (because those are cluster-wide rather than per-database).
    To support convenient dumping of the entire contents of a database
    cluster, the <xref linkend="app-pg-dumpall"/> program is provided.
    <application>pg_dumpall</application> backs up each database in a given
    cluster, and also preserves cluster-wide data such as role and
    tablespace definitions. The basic usage of this command is:
-->
<application>pg_dump</application>は一度に単一のデータベースのみをダンプします。
また、ロールやテーブル空間についての情報はダンプしません。
（これらはテーブル毎ではなくクラスタ全体のものだからです。）
データベースクラスタの全内容の簡便なダンプをサポートするために、<xref linkend="app-pg-dumpall"/>プログラムが提供されています。
<application>pg_dumpall</application>は指定されたクラスタの各データベースのバックアップを行い、そして、ロールやテーブル空間定義などのクラスタ全体にわたるデータを保存します。
このコマンドの基本的な使用方法は
<synopsis>
pg_dumpall &gt; <replaceable>dumpfile</replaceable>
</synopsis>
です。
<!--
    The resulting dump can be restored with <application>psql</application>:
-->
ダンプの結果は<application>psql</application>でリストアできます。
<synopsis>
psql -f <replaceable class="parameter">dumpfile</replaceable> postgres
</synopsis>
<!--
    (Actually, you can specify any existing database name to start from,
    but if you are loading into an empty cluster then <literal>postgres</literal>
    should usually be used.)  It is always necessary to have
    database superuser access when restoring a <application>pg_dumpall</application>
    dump, as that is required to restore the role and tablespace information.
    If you use tablespaces, make sure that the tablespace paths in the
    dump are appropriate for the new installation.
-->
（実際、開始時に任意の既存のデータベース名を指定することができますが、空のクラスタ内にロードする場合は、通常 <literal>postgres</literal> を使用すべきです。）
ロールやテーブル空間の情報をリストアしなければならないので、<application>pg_dumpall</application>のダンプをリストアする時には、データベーススーパーユーザのアクセス権限を確実に必要とします。
テーブル空間を使用している場合、ダンプ内のテーブル空間のパスが新しいインストレーションで適切であることを確認してください。
   </para>

   <para>
<!--
    <application>pg_dumpall</application> works by emitting commands to re-create
    roles, tablespaces, and empty databases, then invoking
    <application>pg_dump</application> for each database.  This means that while
    each database will be internally consistent, the snapshots of
    different databases are not synchronized.
-->
<application>pg_dumpall</application>はコマンドを発令することによりロール、テーブル空間、およびデータベースを再作成し、それぞれのデータベースに対して<application>pg_dump</application>を起動します。
このことは、それぞれのデータベースには内部的に矛盾がない一方、異なるデータベースのスナップショットは完全に同期しないことを示しています。
   </para>

   <para>
<!--
    Cluster-wide data can be dumped alone using the
    <application>pg_dumpall</application> <option>&#45;-globals-only</option> option.
    This is necessary to fully backup the cluster if running the
    <application>pg_dump</application> command on individual databases.
-->
クラスタレベルでのデータは<application>pg_dumpall</application> の<option>--globals-only</option> オプションを使用して出力することができます。
このコマンドは個々のデータベースに<application>pg_dump</application> コマンドを実行しつつ、フルバックアップを取得する際に必要です。
   </para>
  </sect2>

  <sect2 id="backup-dump-large">
<!--
   <title>Handling Large Databases</title>
-->
   <title>大規模データベースの扱い</title>

   <para>
<!--
    Some operating systems have maximum file size limits that cause
    problems when creating large <application>pg_dump</application> output files.
    Fortunately, <application>pg_dump</application> can write to the standard
    output, so you can use standard Unix tools to work around this
    potential problem.  There are several possible methods:
-->
オペレーティングシステムの中には最大ファイルサイズに制限があるものがあり、大きな<application>pg_dump</application>出力ファイルを作成しているときに問題を引き起こします。
幸運なことに、<application>pg_dump</application>は標準出力に書き出すことができますので、Unix標準のツールを使ってこの潜在的な問題を解決できます。
取りうる方法がいくつか存在します。
   </para>

   <formalpara>
<!--
    <title>Use compressed dumps.</title>
-->
    <title>圧縮ダンプの使用</title>
    <para>
<!--
     You can use your favorite compression program, for example
     <application>gzip</application>:
-->
たとえば、自分が愛用している<application>gzip</application>のような圧縮プログラムが使えます。

<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | gzip &gt; <replaceable class="parameter">filename</replaceable>.gz
</programlisting>

<!--
     Reload with:
-->
元に戻すには次のようにします。

<programlisting>
gunzip -c <replaceable class="parameter">filename</replaceable>.gz | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>

<!--
     or:
-->
あるいは次のようにもできます。

<programlisting>
cat <replaceable class="parameter">filename</replaceable>.gz | gunzip | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>
    </para>
   </formalpara>

   <formalpara>
<!--
    <title>Use <command>split</command>.</title>
-->
    <title><command>split</command>の使用</title>
    <para>
<!--
     The <command>split</command> command
     allows you to split the output into smaller files that are
     acceptable in size to the underlying file system. For example, to
     make 2 gigabyte chunks:
-->
<command>split</command>コマンドで結果を使用しているファイルシステムが受け付けられる大きさに分割することができます。
例えば2メガバイトずつに分割するには次のようにします。

<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | split -b 2G - <replaceable class="parameter">filename</replaceable>
</programlisting>

<!--
     Reload with:
-->
元に戻すには次のようにします。

<programlisting>
cat <replaceable class="parameter">filename</replaceable>* | psql <replaceable class="parameter">dbname</replaceable>
</programlisting>

<!--
     If using GNU <application>split</application>, it is possible to
     use it and <application>gzip</application> together:
-->
GNU <application>split</application>を使用している場合は、次のように<application>gzip</application>を一緒に使うことでファイルの圧縮が出来ます。

<programlisting>
pg_dump <replaceable class="parameter">dbname</replaceable> | split -b 2G --filter='gzip > $FILE.gz'
</programlisting>

<!--
     It can be restored using <command>zcat</command>.
-->
圧縮されたファイルは<command>zcat</command>を使ってリストア出来ます。
    </para>
   </formalpara>

   <formalpara>
<!--
    <title>Use <application>pg_dump</application>'s custom dump format.</title>
-->
    <title><application>pg_dump</application>のカスタムダンプ書式の使用</title>
    <para>
<!--
     If <productname>PostgreSQL</productname> was built on a system with the
     <application>zlib</application> compression library installed, the custom dump
     format will compress data as it writes it to the output file. This will
     produce dump file sizes similar to using <command>gzip</command>, but it
     has the added advantage that tables can be restored selectively. The
     following command dumps a database using the custom dump format:
-->
もし<productname>PostgreSQL</productname>が<application>zlib</application>圧縮ライブラリインストール済みのシステム上で構築されたのなら、カスタムダンプ書式では出力ファイルに書き出す時にデータを圧縮します。
<command>gzip</command>を使用した時と似通ったダンプサイズとなりますが、テーブルの復元を部分的に行えるという点で優れていると言えます。
以下のコマンドは、カスタムダンプ書式でのデータベースのダンプを行います。

<programlisting>
pg_dump -Fc <replaceable class="parameter">dbname</replaceable> &gt; <replaceable class="parameter">filename</replaceable>
</programlisting>

<!--
     A custom-format dump is not a script for <application>psql</application>, but
     instead must be restored with <application>pg_restore</application>, for example:
-->
カスタム書式のダンプは<application>psql</application>用のスクリプトではありませんので、代わりに<application>pg_restore</application>でリストアしなければなりません。
例えば以下のようにします。

<programlisting>
pg_restore -d <replaceable class="parameter">dbname</replaceable> <replaceable class="parameter">filename</replaceable>
</programlisting>

<!--
     See the <xref linkend="app-pgdump"/> and <xref
     linkend="app-pgrestore"/> reference pages for details.
-->
詳細は<xref linkend="app-pgdump"/>と<xref linkend="app-pgrestore"/>のリファレンスページを参照してください。
    </para>
   </formalpara>

   <para>
<!--
    For very large databases, you might need to combine <command>split</command>
    with one of the other two approaches.
-->
巨大なデータベースに対しては、そのほかの２つの手法のうちの１つと一緒に<command>split</command>を組み合わせる必要があるかもしれません。
   </para>

   <formalpara>
<!--
    <title>Use <application>pg_dump</application>'s parallel dump feature.</title>
-->
    <title><application>pg_dump</application>の並列実行</title>
    <para>
<!--
     To speed up the dump of a large database, you can use
     <application>pg_dump</application>'s parallel mode. This will dump
     multiple tables at the same time. You can control the degree of
     parallelism with the <command>-j</command> parameter. Parallel dumps
     are only supported for the "directory" archive format.
-->
<application>pg_dump</application>を並列実行することで、大きなデータベースのダンプを高速に実行することができます。
これは同時に複数テーブルのダンプを実行します。
並列度は<command>-j</command>パラメータを指定することで制御できます。
並列ダンプはディレクトリダンプ書式のみサポートします。

<programlisting>
pg_dump -j <replaceable class="parameter">num</replaceable> -F d -f <replaceable class="parameter">out.dir</replaceable> <replaceable class="parameter">dbname</replaceable>
</programlisting>

<!--
     You can use <command>pg_restore -j</command> to restore a dump in parallel.
     This will work for any archive of either the "custom" or the "directory"
     archive mode, whether or not it has been created with <command>pg_dump -j</command>.
-->
<command>pg_restore -j</command>コマンドでダンプファイルを並列でリストアすることができます。
これは<command>pg_dump -j</command>でダンプファイルが作成されたか、否かにかかわらず、カスタムもしくはディレクトリダンプ書式で作成されたダンプファイルに使用できます。
    </para>
   </formalpara>
  </sect2>
 </sect1>

 <sect1 id="backup-file">
<!--
  <title>File System Level Backup</title>
-->
  <title>ファイルシステムレベルのバックアップ</title>

  <para>
<!--
   An alternative backup strategy is to directly copy the files that
   <productname>PostgreSQL</productname> uses to store the data in the database;
   <xref linkend="creating-cluster"/> explains where these files
   are located.  You can use whatever method you prefer
   for doing file system backups; for example:
-->
バックアップ戦略の代替案として<productname>PostgreSQL</productname>がデータベース内のデータを保存するために使用しているファイルを直接コピーする方法があります。
<xref linkend="creating-cluster"/>にこれらのファイルがどこにあるか解説されています。
下記のような通常のファイルシステムのバックアップを行うどんな方法でも問題ありません。

<programlisting>
tar -cf backup.tar /usr/local/pgsql/data
</programlisting>
  </para>

  <para>
<!--
   There are two restrictions, however, which make this method
   impractical, or at least inferior to the <application>pg_dump</application>
   method:
-->
しかしこの方法には2つの制約があり、そのためにあまり実用的ではなく、少なくとも<application>pg_dump</application>より劣ると言わざるを得ません。

   <orderedlist>
    <listitem>
     <para>
<!--
      The database server <emphasis>must</emphasis> be shut down in order to
      get a usable backup. Half-way measures such as disallowing all
      connections will <emphasis>not</emphasis> work
      (in part because <command>tar</command> and similar tools do not take
      an atomic snapshot of the state of the file system,
      but also because of internal buffering within the server).
      Information about stopping the server can be found in
      <xref linkend="server-shutdown"/>.  Needless to say, you
      also need to shut down the server before restoring the data.
-->
有効なバックアップを行うにはデータベースサーバを<emphasis>必ず</emphasis>停止しなければなりません。
全ての接続を無効とするような中途半端な対策では作用<emphasis>しません</emphasis>
（<command>tar</command>やその類似ツールはある時点におけるファイルシステムの原子的なスナップショットを取らないことと同時に、サーバ内の内部バッファリングの理由によるからです）。
サーバの停止に関しては<xref linkend="server-shutdown"/>を参照してください。
言うまでもありませんが、データをリストアする前にもサーバを停止させる必要があります。
     </para>
    </listitem>

    <listitem>
     <para>
<!--
      If you have dug into the details of the file system layout of the
      database, you might be tempted to try to back up or restore only certain
      individual tables or databases from their respective files or
      directories. This will <emphasis>not</emphasis> work because the
      information contained in these files is not usable without
      the commit log files,
      <filename>pg_xact/*</filename>, which contain the commit status of
      all transactions. A table file is only usable with this
      information. Of course it is also impossible to restore only a
      table and the associated <filename>pg_xact</filename> data
      because that would render all other tables in the database
      cluster useless.  So file system backups only work for complete
      backup and restoration of an entire database cluster.
-->
データベースのファイルシステムレイアウトの詳細を熟知している場合、ある個別のテーブルやデータベースをそれぞれのファイルやディレクトリからバックアップしたり復元したりすることを試みたいと思うかもしれません。
しかし、それらのファイル内の情報はすべてのトランザクションのコミット状態を保持するコミットログファイル<filename>pg_xact/*</filename>なしでは使えないため、この方法では正常なバックアップは<emphasis>行えません</emphasis>。
テーブルファイルはこの情報があって初めて意味をなします。
もちろんテーブルとそれに付帯する<filename>pg_xact</filename>データだけで復元することも、データベースクラスタにある他のテーブルを無効としてしまうのでできません。
ですので、ファイルシステムバックアップは、データベースクラスタ全体の完全なバックアップとリストア処理にのみ動作します。
     </para>
    </listitem>
   </orderedlist>
  </para>

  <para>
<!--
   An alternative file-system backup approach is to make a
   <quote>consistent snapshot</quote> of the data directory, if the
   file system supports that functionality (and you are willing to
   trust that it is implemented correctly).  The typical procedure is
   to make a <quote>frozen snapshot</quote> of the volume containing the
   database, then copy the whole data directory (not just parts, see
   above) from the snapshot to a backup device, then release the frozen
   snapshot.  This will work even while the database server is running.
   However, a backup created in this way saves
   the database files in a state as if the database server was not
   properly shut down; therefore, when you start the database server
   on the backed-up data, it will think the previous server instance
   crashed and will replay the WAL log.  This is not a problem; just
   be aware of it (and be sure to include the WAL files in your backup).
   You can perform a <command>CHECKPOINT</command> before taking the
   snapshot to reduce recovery time.
-->
その他のファイルシステムバックアップ方法として、ファイルシステムが<quote>整合性を維持したスナップショット</quote>機能をサポートしている場合（かつ、正しく実装されていると信用する場合）、データディレクトリのスナップショットを作成する方法があります。
典型的な手順では、データベースを含むボリュームの<quote>凍結スナップショット</quote>を作成し、データディレクトリ全体（上述のように、一部だけではいけません）をスナップショットからバックアップデバイスにコピーし、そして、凍結スナップショットを解放します。
これはデータベースサーバが稼動中であっても動作します。
しかし、こうして作成されたバックアップは、データベースサーバが適切に停止されなかった状態のデータベースファイルを保存します。
そのため、このバックアップデータでデータベースサーバを起動する時、直前のサーバインスタンスがクラッシュしたものとみなされ、WALログが取り直されます。
これは問題ではありません。
単に注意してください（そして、確実にバックアップにWALファイルを含めてください）。
<command>CHECKPOINT</command>コマンドをスナップショット取得前に発行することで復旧時間を減らすこともできます。
  </para>

  <para>
<!--
   If your database is spread across multiple file systems, there might not
   be any way to obtain exactly-simultaneous frozen snapshots of all
   the volumes.  For example, if your data files and WAL log are on different
   disks, or if tablespaces are on different file systems, it might
   not be possible to use snapshot backup because the snapshots
   <emphasis>must</emphasis> be simultaneous.
   Read your file system documentation very carefully before trusting
   the consistent-snapshot technique in such situations.
-->
対象のデータベースが複数のファイルシステムにまたがって分散している場合、全てのボリュームに対して完全に同期した凍結スナップショットを得る方法が存在しない可能性があります。
例えば、データファイルとWALログが異なったディスク上にあったり、テーブル空間が異なるファイルシステム上にある場合、スナップショットは同時でなければ<emphasis>なりません</emphasis>ので、スナップショットのバックアップを使用できない可能性があります。
こうした状況では、整合性を維持したスナップショット技術を信用する前に使用するファイルシステムの文書を熟読してください。
  </para>

  <para>
<!--
   If simultaneous snapshots are not possible, one option is to shut down
   the database server long enough to establish all the frozen snapshots.
   Another option is to perform a continuous archiving base backup (<xref
   linkend="backup-base-backup"/>) because such backups are immune to file
   system changes during the backup.  This requires enabling continuous
   archiving just during the backup process; restore is done using
   continuous archive recovery (<xref linkend="backup-pitr-recovery"/>).
-->
同時実行のスナップショットができない場合、選択肢の１つとして、全ての機能の停止したスナップショットを確定させるのに充分な時間、データベースサーバをシャットダウンさせることが挙げられます。
他の選択肢は、継続的なベースバックアップの保管（<xref linkend="backup-base-backup"/>）を行うことです。
こうしたバックアップには、バックアップ中のファイルシステムの変更を心配する必要がないためです。
これにはバックアップ処理期間のみに継続的な保管を行う必要があり、継続的なアーカイブリカバリ（<xref linkend="backup-pitr-recovery"/>）を使用してリストアを行います。
  </para>

  <para>
<!--
   Another option is to use <application>rsync</application> to perform a file
   system backup.  This is done by first running <application>rsync</application>
   while the database server is running, then shutting down the database
   server long enough to do an <command>rsync &#45;-checksum</command>.
   (<option>&#45;-checksum</option> is necessary because <command>rsync</command> only
   has file modification-time granularity of one second.)  The
   second <application>rsync</application> will be quicker than the first,
   because it has relatively little data to transfer, and the end result
   will be consistent because the server was down.  This method
   allows a file system backup to be performed with minimal downtime.
-->
ファイルシステムをバックアップするその他の選択肢として<application>rsync</application>の使用が挙げられます。
これを行うには、先ずデータベースサーバが稼働中に<application>rsync</application>を実行し、そして<command>rsync --checksum</command>を実行するのに充分な間だけデータベースサーバを停止します。
(<command>rsync</command>はファイルの更新時刻に関して1秒の粒度しかありませんので、<option>--checksum</option>が必要です。)
次の<application>rsync</application>は、比較的転送するデータ量が少なく、サーバが稼働していないため最終結果に矛盾がない事から、最初の<application>rsync</application>よりも迅速です。
この方法で最小の稼働停止時間でファイルシステムのバックアップを行う事ができます。
  </para>

  <para>
<!--
   Note that a file system backup will typically be larger
   than an SQL dump. (<application>pg_dump</application> does not need to dump
   the contents of indexes for example, just the commands to recreate
   them.)  However, taking a file system backup might be faster.
-->
ファイルシステムバックアップは、概してSQLによるダンプより大きくなることに注意してください。
（<application>pg_dump</application>では、例えばインデックスの内容をダンプする必要はありません。単にコマンドで再作成します。）
しかし、ファイルシステムのバックアップを取るほうがより高速でしょう。
  </para>
 </sect1>

 <sect1 id="continuous-archiving">
<!--
  <title>Continuous Archiving and Point-in-Time Recovery (PITR)</title>
-->
  <title>継続的アーカイブとポイントインタイムリカバリ（PITR）</title>

  <indexterm zone="backup">
   <primary>continuous archiving</primary>
  </indexterm>
  <indexterm zone="backup">
   <primary>継続的アーカイブ</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>point-in-time recovery</primary>
  </indexterm>
  <indexterm zone="backup">
   <primary>ポイントインタイムリカバリ</primary>
  </indexterm>

  <indexterm zone="backup">
   <primary>PITR</primary>
  </indexterm>

  <para>
<!--
   At all times, <productname>PostgreSQL</productname> maintains a
   <firstterm>write ahead log</firstterm> (WAL) in the <filename>pg_wal/</filename>
   subdirectory of the cluster's data directory. The log records
   every change made to the database's data files.  This log exists
   primarily for crash-safety purposes: if the system crashes, the
   database can be restored to consistency by <quote>replaying</quote> the
   log entries made since the last checkpoint.  However, the existence
   of the log makes it possible to use a third strategy for backing up
   databases: we can combine a file-system-level backup with backup of
   the WAL files.  If recovery is needed, we restore the file system backup and
   then replay from the backed-up WAL files to bring the system to a
   current state.  This approach is more complex to administer than
   either of the previous approaches, but it has some significant
   benefits:
-->
<productname>PostgreSQL</productname>は常に、クラスタのデータディレクトリ以下の<filename>pg_wal/</filename>ディレクトリ内で<firstterm>先行書き込みログ</firstterm>（WAL）を管理しています。
このログはデータベースのデータファイルに行われた全ての変更を記録します。
このログは主にクラッシュ時の安全性を目的としています。
システムがクラッシュしたとしても、最後のチェックポイント以降に作成されたログ項目を<quote>やり直し</quote>することで、データベースを整合性を維持した状態にリストアすることができます。
しかし、この存在するログファイルを使用して、データベースのバックアップ用の第3の戦略が可能になりました。
ファイルシステムレベルのバックアップとWALファイルのバックアップを組み合わせるという戦略です。
復旧が必要ならば、ファイルシステムバックアップをリストアし、その後にバックアップされたWALファイルを再生することで、システムを最新の状態にできます。
管理者にとって、この方法はこれまで説明した方法よりかなり複雑になりますが、以下のような大きな利点が複数あります。
  <itemizedlist>
   <listitem>
    <para>
<!--
     We do not need a perfectly consistent file system backup as the starting point.
     Any internal inconsistency in the backup will be corrected by log
     replay (this is not significantly different from what happens during
     crash recovery).  So we do not need a file system snapshot capability,
     just <application>tar</application> or a similar archiving tool.
-->
開始時点のファイルシステムバックアップは完全な整合状態である必要はありません。
そのバックアップ内の内部的な不整合はログのやり直しによって修正されます
（これは、クラッシュからの復旧時に行われることと大きな違いはありません）。
ですので、ファイルシステムのスナップショット機能を必要としません。
単に<application>tar</application>などのアーカイブツールが必要です。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     Since we can combine an indefinitely long sequence of WAL files
     for replay, continuous backup can be achieved simply by continuing to archive
     the WAL files.  This is particularly valuable for large databases, where
     it might not be convenient to take a full backup frequently.
-->
再生の際にWALファイルの並びを数に制限なく連ねて組み合わせられますので、単にWALファイルのアーカイブを続けることで連続したバックアップを達成できます。
これは、頻繁に完全なバックアップを行うことが困難な、大規模なデータベースでは特に価値があります。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     It is not necessary to replay the WAL entries all the
     way to the end.  We could stop the replay at any point and have a
     consistent snapshot of the database as it was at that time.  Thus,
     this technique supports <firstterm>point-in-time recovery</firstterm>: it is
     possible to restore the database to its state at any time since your base
     backup was taken.
-->
WAL項目の再生を最後まで行わなければならないということはありません。
やり直しを任意の時点までで停止することができ、それにより、その時点までのデータベースの整合性を持ったスナップショットを得ることができます。
このような技術が<firstterm>ポイントインタイムリカバリ</firstterm>を補助するものであり、元となるベースバックアップの取得時点以降の任意の時点の状態にデータベースをリストアすることが可能になります。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     If we continuously feed the series of WAL files to another
     machine that has been loaded with the same base backup file, we
     have a <firstterm>warm standby</firstterm> system: at any point we can bring up
     the second machine and it will have a nearly-current copy of the
     database.
-->
連続的に一連のWALファイルを、同一のベースバックアップをロードしている別のマシンに配送することで、<firstterm>ウォームスタンバイ</firstterm>システムを保有することができます。
つまり、任意の時点でその2番目のマシンを、ほぼ現時点のデータベースの複製を持った状態で有効にすることができます。
    </para>
   </listitem>
  </itemizedlist>
  </para>

  <note>
   <para>
<!--
    <application>pg_dump</application> and
    <application>pg_dumpall</application> do not produce file-system-level
    backups and cannot be used as part of a continuous-archiving solution.
    Such dumps are <emphasis>logical</emphasis> and do not contain enough
    information to be used by WAL replay.
-->
<application>pg_dump</application>と<application>pg_dumpall</application>はファイルシステムレベルのバックアップを生成しませんので、継続的アーカイブ方式の一部として使うことはできません。
そのダンプは<emphasis>論理的</emphasis>なものであり、WALのやり直しで使うのに十分な情報を含んでいません。
   </para>
  </note>

  <para>
<!--
   As with the plain file-system-backup technique, this method can only
   support restoration of an entire database cluster, not a subset.
   Also, it requires a lot of archival storage: the base backup might be bulky,
   and a busy system will generate many megabytes of WAL traffic that
   have to be archived.  Still, it is the preferred backup technique in
   many situations where high reliability is needed.
-->
通常のファイルシステムバックアップ技術の場合と同様、この方法は、一部ではなく、データベースクラスタ全体のリストア処理のみをサポートできます。
また、アーカイブ用に大量の格納領域を必要とします。
ベースバックアップはかさばる場合があり、また、高負荷なシステムではアーカイブしなければならないWALの流量をメガバイト単位で生成します。
しかし、これは、高信頼性が必要な、多くの状況でむしろ好まれるバックアップ手法です。
  </para>

  <para>
<!--
   To recover successfully using continuous archiving (also called
   <quote>online backup</quote> by many database vendors), you need a continuous
   sequence of archived WAL files that extends back at least as far as the
   start time of your backup.  So to get started, you should set up and test
   your procedure for archiving WAL files <emphasis>before</emphasis> you take your
   first base backup.  Accordingly, we first discuss the mechanics of
   archiving WAL files.
-->
継続的アーカイブ（多くのデータベースベンダで<quote>オンラインバックアップ</quote>とも呼ばれます）を使用して復旧を成功させるためには、少なくともバックアップの開始時点まで遡る、連続した一連のアーカイブ済みWALファイルが必要です。
ですので、運用するためには、最初のベースバックアップを取得する<emphasis>前</emphasis>にWALファイルをアーカイブする手順を設定し試験しなければなりません。
したがって、まずWALファイルのアーカイブ機構について説明します。
  </para>

  <sect2 id="backup-archiving-wal">
<!--
   <title>Setting Up WAL Archiving</title>
-->
   <title>WALアーカイブの設定</title>

   <para>
<!--
    In an abstract sense, a running <productname>PostgreSQL</productname> system
    produces an indefinitely long sequence of WAL records.  The system
    physically divides this sequence into WAL <firstterm>segment
    files</firstterm>, which are normally 16MB apiece (although the segment size
    can be altered during <application>initdb</application>).  The segment
    files are given numeric names that reflect their position in the
    abstract WAL sequence.  When not using WAL archiving, the system
    normally creates just a few segment files and then
    <quote>recycles</quote> them by renaming no-longer-needed segment files
    to higher segment numbers.  It's assumed that segment files whose
    contents precede the last checkpoint are no longer of
    interest and can be recycled.
-->
抽象的な意味では、実行中の<productname>PostgreSQL</productname>システムは無限に長い一連のWALレコードを生成します。
システムは物理的にこの並びを、通常1つ16メガバイト（このセグメントサイズは<application>initdb</application>の実行時に変更可能です）の、WAL<firstterm>セグメントファイル</firstterm>に分割します。
このセグメントファイルには、概念的なWALの並び内の位置を反映した、数字の名前が付与されます。
WALアーカイブを行わない場合、システムは通常数個のセグメントファイルを生成し、不要となったセグメントファイルの名前をより大きなセグメント番号に変更することでそれを<quote>リサイクル</quote>します。
最後のチェックポイントより前の内容を持つセグメントファイルはもはや重要でなく、リサイクルできると見なされます。
   </para>

   <para>
<!--
    When archiving WAL data, we need to capture the contents of each segment
    file once it is filled, and save that data somewhere before the segment
    file is recycled for reuse.  Depending on the application and the
    available hardware, there could be many different ways of <quote>saving
    the data somewhere</quote>: we could copy the segment files to an NFS-mounted
    directory on another machine, write them onto a tape drive (ensuring that
    you have a way of identifying the original name of each file), or batch
    them together and burn them onto CDs, or something else entirely.  To
    provide the database administrator with flexibility,
    <productname>PostgreSQL</productname> tries not to make any assumptions about how
    the archiving will be done.  Instead, <productname>PostgreSQL</productname> lets
    the administrator specify a shell command or an archive library to be executed to copy a
    completed segment file to wherever it needs to go.  This could be as simple
    as a shell command that uses <literal>cp</literal>, or it could invoke a
    complex C function &mdash; it's all up to you.
-->
WALデータをアーカイブする場合、完成したセグメントファイルのそれぞれの内容を取り出し、再利用のために回収される前にそのデータをどこかに保存することが必要です。
アプリケーションと利用できるハードウェアに依存しますが、数多くの<quote>データをどこかに保存する</quote>方法があります。
例えば、NFSでマウントした他のマシンのディレクトリにセグメントファイルをコピーすること、あるいは、テープ装置に書き出すこと（元々のファイル名を識別する手段があることを確認してください）、それらを一度にまとめてCDに焼くこと、そのほか全く異なったなんらかの方法などです。
柔軟性をデータベース管理者に提供するために、<productname>PostgreSQL</productname>は、どのようにアーカイブがなされたかについて一切想定しないようになっています。
その代わりに<productname>PostgreSQL</productname>は、管理者に完全なセグメントファイルをどこか必要な場所にコピーするシェルコマンドあるいはアーカイブライブラリを指定させます。
このコマンドは単純な<literal>cp</literal>を使ったシェルコマンドでも構いませんし、また、複雑なC関数を呼び出しても構いません。
全て管理者に任されています。
   </para>

   <para>
<!--
    To enable WAL archiving, set the <xref linkend="guc-wal-level"/>
    configuration parameter to <literal>replica</literal> or higher,
    <xref linkend="guc-archive-mode"/> to <literal>on</literal>,
    specify the shell command to use in the <xref
    linkend="guc-archive-command"/> configuration parameter
    or specify the library to use in the <xref
    linkend="guc-archive-library"/> configuration parameter.  In practice
    these settings will always be placed in the
    <filename>postgresql.conf</filename> file.
-->
WALアーカイブを有効にするには、<xref linkend="guc-wal-level"/>設定パラメータを<literal>replica</literal>以上に、<xref linkend="guc-archive-mode"/>を<literal>on</literal>に設定し、<xref linkend="guc-archive-command"/>設定パラメータで使用するシェルコマンドを指定するか、<xref linkend="guc-archive-library"/>設定パラメータで使用するライブラリを指定します。
実際には、これらの設定は常に<filename>postgresql.conf</filename>ファイルに置かれます。
   </para>

   <para>
<!--
    In <varname>archive_command</varname>,
    <literal>%p</literal> is replaced by the path name of the file to
    archive, while <literal>%f</literal> is replaced by only the file name.
    (The path name is relative to the current working directory,
    i.e., the cluster's data directory.)
    Use <literal>%%</literal> if you need to embed an actual <literal>%</literal>
    character in the command.  The simplest useful command is something
    like:
-->
<varname>archive_command</varname>では、<literal>%p</literal>はアーカイブするファイルのパス名に置き換えられますが、<literal>%f</literal>はファイル名のみに置き換えられます。
（パス名は現在の作業ディレクトリ、つまりクラスタのデータディレクトリからの相対パスです。）
実際の<literal>%</literal>文字をコマンドに埋め込む必要がある場合は<literal>%%</literal>を使用してください。
最も簡単で便利なコマンドは以下のようなものです。
<programlisting>
archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows
</programlisting>
<!--
    which will copy archivable WAL segments to the directory
    <filename>/mnt/server/archivedir</filename>.  (This is an example, not a
    recommendation, and might not work on all platforms.)  After the
    <literal>%p</literal> and <literal>%f</literal> parameters have been replaced,
    the actual command executed might look like this:
-->
これは、アーカイブ可能なWALセグメントを<filename>/mnt/server/archivedir</filename>ディレクトリにコピーします
（これは一例です。
推奨するものではなく、また、全てのプラットフォームで動作しない可能性があります）。
<literal>%p</literal>および<literal>%f</literal>パラメータが置き換えられたあと、実行された実コマンドは以下のようになります。
<programlisting>
test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_wal/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065
</programlisting>
<!--
    A similar command will be generated for each new file to be archived.
-->
類似したコマンドがアーカイブされるそれぞれの新規ファイルに生成されます。
   </para>

   <para>
<!--
    The archive command will be executed under the ownership of the same
    user that the <productname>PostgreSQL</productname> server is running as.  Since
    the series of WAL files being archived contains effectively everything
    in your database, you will want to be sure that the archived data is
    protected from prying eyes; for example, archive into a directory that
    does not have group or world read access.
-->
このアーカイブ用コマンドは<productname>PostgreSQL</productname>サーバを稼動させるユーザと同じ所有権で実行されます。
アーカイブされる一連のWALファイルには、実質、データベース内の全てが含まれていますので、アーカイブしたデータをのぞき見から確実に保護しなければならないでしょう。
例えば、グループや全員に読み込み権限を付与していないディレクトリにデータをアーカイブしてください。
   </para>

   <para>
<!--
    It is important that the archive command return zero exit status if and
    only if it succeeds.  Upon getting a zero result,
    <productname>PostgreSQL</productname> will assume that the file has been
    successfully archived, and will remove or recycle it.  However, a nonzero
    status tells <productname>PostgreSQL</productname> that the file was not archived;
    it will try again periodically until it succeeds.
-->
アーカイブ用コマンドが成功した場合のみにゼロという終了ステータスを返すことが重要です。
<productname>PostgreSQL</productname>は、ゼロという結果に基づいて、そのファイルのアーカイブが成功したことを想定し、そのファイルを削除したり回収するかもしれません。
しかし、非ゼロのステータスは、<productname>PostgreSQL</productname>に対してファイルがアーカイブされなかったことを通知し、成功するまで定期的に再試行させます。
   </para>

   <para>
<!--
    Another way to archive is to use a custom archive module as the
    <varname>archive_library</varname>.  Since such modules are written in
    <literal>C</literal>, creating your own may require considerably more effort
    than writing a shell command.  However, archive modules can be more
    performant than archiving via shell, and they will have access to many
    useful server resources.  For more information about archive modules, see
    <xref linkend="archive-modules"/>.
-->
アーカイブするための別の方法は、<varname>archive_library</varname>としてカスタム・アーカイブ・モジュールを使用することです。
このようなモジュールは<literal>C</literal>で記述されているため、独自のモジュールを作成するには、シェル・コマンドを記述するよりもかなり多くの労力が必要になる場合があります。
しかし、アーカイブ・モジュールはシェルを介したアーカイブよりもパフォーマンスが高く、多くの有用なサーバー・リソースにアクセスできます。
アーカイブ・モジュールの詳細は<xref linkend="archive-modules"/>を参照してください。
   </para>

   <para>
<!--
    When the archive command is terminated by a signal (other than
    <systemitem>SIGTERM</systemitem> that is used as part of a server
    shutdown) or an error by the shell with an exit status greater than
    125 (such as command not found), or if the archive function emits an
    <literal>ERROR</literal> or <literal>FATAL</literal>, the archiver process
    aborts and gets restarted by the postmaster. In such cases, the failure is
    not reported in <xref linkend="pg-stat-archiver-view"/>.
-->
アーカイブコマンドがシグナル（サーバのシャットダウンの一部として使用される<systemitem>SIGTERM</systemitem>以外）やシェルによる125以上の終了ステータスを持つエラー（command not foundなど）、あるいはアーカイブ関数が<literal>ERROR</literal>または<literal>FATAL</literal>を出力したことによって終了すると、アーカイバプロセスは中止され、postmasterによって再起動されます。
このような場合、失敗は<xref linkend="pg-stat-archiver-view"/>では報告されません。
   </para>

   <para>
<!--
    Archive commands and libraries should generally be designed to refuse to overwrite
    any pre-existing archive file.  This is an important safety feature to
    preserve the integrity of your archive in case of administrator error
    (such as sending the output of two different servers to the same archive
    directory).
-->
通常アーカイブ用コマンドあるいはライブラリは、既存のアーカイブ済みファイルの上書きを行わないように設計されなければなりません。
これは、管理者のミス（例えば2つの異なるサーバの出力を同一のアーカイブ用ディレクトリに送信してしまうなど）といった場合からアーカイブ状況の整合性を保護するための安全策として重要です。
   </para>

   <para>
<!--
    It is advisable to test your proposed archive command or library to ensure that it
    indeed does not overwrite an existing file, <emphasis>and that it returns
    nonzero status or <literal>false</literal>, respectively, in this case</emphasis>.
    The example command above for Unix ensures this by including a separate
    <command>test</command> step.  On some Unix platforms, <command>cp</command> has
    switches such as <option>-i</option> that can be used to do the same thing
    less verbosely, but you should not rely on these without verifying that
    the right exit status is returned.  (In particular, GNU <command>cp</command>
    will return status zero when <option>-i</option> is used and the target file
    already exists, which is <emphasis>not</emphasis> the desired behavior.)
-->
使用予定のアーカイブ用コマンドあるいはライブラリが、当然のことながら既存のファイルを上書きしないこと、<emphasis>かつ、上書きしようとした場合には非ゼロのステータスあるいは<literal>false</literal>をそれぞれ返すこと</emphasis>を確認するために試験することを勧めます。
上のUnix用のコマンド例では、別途<command>test</command>という段階を含めることでこれを確認しています。
いくつかのUnixプラットフォームでは<command>cp</command>コマンドには<option>-i</option> 引数を使うことで煩雑な出力を少なくし使うことができますが、正しい終了コードが返ることを確認せずに使用するべきではありません。
（具体的にはGNUの<command>cp</command>コマンドは<option>-i</option> オプションを使い、ターゲットファイルがすでに存在している場合、ゼロのステータスを返します。これは<emphasis>期待していない</emphasis>動作です。）
   </para>

   <para>
<!--
    While designing your archiving setup, consider what will happen if
    the archive command or library fails repeatedly because some aspect requires
    operator intervention or the archive runs out of space. For example, this
    could occur if you write to tape without an autochanger; when the tape
    fills, nothing further can be archived until the tape is swapped.
    You should ensure that any error condition or request to a human operator
    is reported appropriately so that the situation can be
    resolved reasonably quickly. The <filename>pg_wal/</filename> directory will
    continue to fill with WAL segment files until the situation is resolved.
    (If the file system containing <filename>pg_wal/</filename> fills up,
    <productname>PostgreSQL</productname> will do a PANIC shutdown.  No committed
    transactions will be lost, but the database will remain offline until
    you free some space.)
-->
アーカイブ設定を設計する時には、操作者の介入が必要であったり、アーカイブ場所の容量不足の理由でアーカイブ用コマンドあるいはライブラリが繰り返し失敗した時にどうなるかを考慮してください。
例えば、これはオートチェンジャ機能のないテープに書き出している場合に発生する可能性があります。
テープが一杯になった場合、テープを交換するまでアーカイブを行うことができなくなります。
こうした状況を相応の早さで解消できるよう、適切に操作者に対しエラーや要求を確実に連絡できるようにしなければなりません。
この状況が解消するまで、WALセグメントファイルは<filename>pg_wal/</filename>ディレクトリ内に格納され続けます。
（<filename>pg_wal/</filename>を含むファイルシステムがいっぱいになると、<productname>PostgreSQL</productname>はパニック停止します。コミットされたトランザクションは失われませんが、データベースはいくらかの容量を解放するまでオフラインのままです。）
   </para>

   <para>
<!--
    The speed of the archive command or library is unimportant as long as it can keep up
    with the average rate at which your server generates WAL data.  Normal
    operation continues even if the archiving process falls a little behind.
    If archiving falls significantly behind, this will increase the amount of
    data that would be lost in the event of a disaster. It will also mean that
    the <filename>pg_wal/</filename> directory will contain large numbers of
    not-yet-archived segment files, which could eventually exceed available
    disk space. You are advised to monitor the archiving process to ensure that
    it is working as you intend.
-->
サーバのWALデータの生成に要する平均速度に追いついている限り、アーカイブ用コマンドあるいはライブラリの処理速度は重要ではありません。
アーカイブプロセスが多少遅れたとしても通常の操作は続けられます。
アーカイブ処理がかなり遅れると、災害時に損失するデータの量が増加することになります。
また、これは<filename>pg_wal/</filename>ディレクトリ内に多くのアーカイブ処理待ちのセグメントファイルが格納され、ディスク容量が不足する状況になる可能性があることを意味します。
アーカイブ処理が確実に意図通りに動作しているかを監視することを推奨します。
   </para>

   <para>
<!--
    In writing your archive command or library, you should assume that the file names to
    be archived can be up to 64 characters long and can contain any
    combination of ASCII letters, digits, and dots.  It is not necessary to
    preserve the original relative path (<literal>%p</literal>) but it is necessary to
    preserve the file name (<literal>%f</literal>).
-->
アーカイブ用コマンドあるいはライブラリを作成する時、アーカイブされるファイル名は最長64文字までで、ASCII文字と数字とドットのどんな組合せを使用しても構いません。
元の相対パス（<literal>%p</literal>）を保存する必要はありませんが、ファイル名（<literal>%f</literal>）を保存する必要はあります。
   </para>

   <para>
<!--
    Note that although WAL archiving will allow you to restore any
    modifications made to the data in your <productname>PostgreSQL</productname> database,
    it will not restore changes made to configuration files (that is,
    <filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename> and
    <filename>pg_ident.conf</filename>), since those are edited manually rather
    than through SQL operations.
    You might wish to keep the configuration files in a location that will
    be backed up by your regular file system backup procedures.  See
    <xref linkend="runtime-config-file-locations"/> for how to relocate the
    configuration files.
-->
WALアーカイブによって<productname>PostgreSQL</productname>データベースでなされた変更は全てリストアすることができますが、設定ファイルはSQL操作ではなく手作業で変更されますので、設定ファイル（<filename>postgresql.conf</filename>、<filename>pg_hba.conf</filename>、および<filename>pg_ident.conf</filename>）になされた変更までリストアしないことに注意してください。
通常のファイルシステムバックアップ手続きでバックアップされる場所に設定ファイルを保持したい場合があります。
設定ファイルの設置場所を変更するには<xref linkend="runtime-config-file-locations"/>を参照してください。
   </para>

   <para>
<!--
    The archive command or function is only invoked on completed WAL segments.  Hence,
    if your server generates only little WAL traffic (or has slack periods
    where it does so), there could be a long delay between the completion
    of a transaction and its safe recording in archive storage.  To put
    a limit on how old unarchived data can be, you can set
    <xref linkend="guc-archive-timeout"/> to force the server to switch
    to a new WAL segment file at least that often.  Note that archived
    files that are archived early due to a forced switch are still the same
    length as completely full files.  It is therefore unwise to set a very
    short <varname>archive_timeout</varname> &mdash; it will bloat your archive
    storage.  <varname>archive_timeout</varname> settings of a minute or so are
    usually reasonable.
-->
アーカイブコマンドあるいは関数は完全なWALセグメントに対してのみ呼び出されます。
このため、サーバが少ししかWAL流量がない（処理を行わないなぎの期間がある）場合、トランザクションの完了とアーカイブ格納領域への安全な記録との間に長期にわたる遅延があることになります。
古い未アーカイブのデータをどうするかについて制限を付けるために、<xref linkend="guc-archive-timeout"/>を設定して、強制的にサーバを新しいWALセグメントにある程度の間隔で切り替えるようにすることができます。
強制切り替えにより早期にアーカイブされたアーカイブ済みファイルは完全に完了したファイルと同じ大きさを持つことに注意してください。
そのため、非常に小さな<varname>archive_timeout</varname>を使用することはお勧めしません。
格納領域を膨張させてしまいます。
通常ならば分単位の<varname>archive_timeout</varname>設定が合理的です。
   </para>

   <para>
<!--
    Also, you can force a segment switch manually with
    <function>pg_switch_wal</function> if you want to ensure that a
    just-finished transaction is archived as soon as possible.  Other utility
    functions related to WAL management are listed in <xref
    linkend="functions-admin-backup-table"/>.
-->
終わったばかりのトランザクションをできるだけ早くアーカイブさせたい場合、<function>pg_switch_wal</function>を使用して手作業でセグメント切り替えを強制することができます。
この他のWAL管理に関連した関数を<xref linkend="functions-admin-backup-table"/>に列挙します。
   </para>

   <para>
<!--
    When <varname>wal_level</varname> is <literal>minimal</literal> some SQL commands
    are optimized to avoid WAL logging, as described in <xref
    linkend="populate-pitr"/>.  If archiving or streaming replication were
    turned on during execution of one of these statements, WAL would not
    contain enough information for archive recovery.  (Crash recovery is
    unaffected.)  For this reason, <varname>wal_level</varname> can only be changed at
    server start.  However, <varname>archive_command</varname> and <varname>archive_library</varname> can be changed with a
    configuration file reload.  If you are archiving via shell and wish to
    temporarily stop archiving,
    one way to do it is to set <varname>archive_command</varname> to the empty
    string (<literal>''</literal>).
    This will cause WAL files to accumulate in <filename>pg_wal/</filename> until a
    working <varname>archive_command</varname> is re-established.
-->
<varname>wal_level</varname>が<literal>minimal</literal>の場合、<xref linkend="populate-pitr"/>に書かれているように、いくつかのSQLコマンドはWALロギングを回避するため最適化されます。
アーカイビングもしくはストリーミングレプリケーションがこれら構文の１つを実行中に作動させられると、アーカイブ復旧のための十分な情報をWALが含まなくなります。（クラッシュ復旧は影響を受けません。）
このことにより、<varname>wal_level</varname>はサーバの起動時のみ変更可能です。
とは言っても、<varname>archive_command</varname>と<varname>archive_library</varname>は構成ファイルを再読み込みすることで変更できます。
シェルでアーカイブしており、一時的にアーカイビングを停止したい場合、１つの方法は<varname>archive_command</varname>を空文字列（<literal>''</literal>）に設定することです。
このようにすると、動作する<varname>archive_command</varname>が再構築されるまでWALファイルは<filename>pg_wal/</filename>に蓄積します。
   </para>
  </sect2>

  <sect2 id="backup-base-backup">
<!--
   <title>Making a Base Backup</title>
-->
   <title>ベースバックアップの作成</title>

   <para>
<!--
    The easiest way to perform a base backup is to use the
    <xref linkend="app-pgbasebackup"/> tool. It can create
    a base backup either as regular files or as a tar archive. If more
    flexibility than <xref linkend="app-pgbasebackup"/> can provide is
    required, you can also make a base backup using the low level API
    (see <xref linkend="backup-lowlevel-base-backup"/>).
-->
ベースバックアップを取得する最も簡単な方法は<xref linkend="app-pgbasebackup"/> を実行する方法です。
通常のファイルやTAR形式のファイルとしてベースバックアップを取得することができます。
もし、<xref linkend="app-pgbasebackup"/>より柔軟性が求められる場合は、低レベルなAPIを使ってバックアップを作成することもできます（詳細は <xref linkend="backup-lowlevel-base-backup"/>を参照）。
   </para>

   <para>
<!--
    It is not necessary to be concerned about the amount of time it takes
    to make a base backup. However, if you normally run the
    server with <varname>full_page_writes</varname> disabled, you might notice a drop
    in performance while the backup runs since <varname>full_page_writes</varname> is
    effectively forced on during backup mode.
-->
ベースバックアップを取得するための時間を考慮する必要はありません。
しかし、普段、<varname>full_page_writes</varname>を無効にして運用している場合、バックアップ取得中は強制的に<varname>full_page_writes</varname>が有効になるため、パフォーマンスが落ちていると感じる可能性があります。
   </para>

   <para>
<!--
    To make use of the backup, you will need to keep all the WAL
    segment files generated during and after the file system backup.
    To aid you in doing this, the base backup process
    creates a <firstterm>backup history file</firstterm> that is immediately
    stored into the WAL archive area. This file is named after the first
    WAL segment file that you need for the file system backup.
    For example, if the starting WAL file is
    <literal>0000000100001234000055CD</literal> the backup history file will be
    named something like
    <literal>0000000100001234000055CD.007C9330.backup</literal>. (The second
    part of the file name stands for an exact position within the WAL
    file, and can ordinarily be ignored.) Once you have safely archived
    the file system backup and the WAL segment files used during the
    backup (as specified in the backup history file), all archived WAL
    segments with names numerically less are no longer needed to recover
    the file system backup and can be deleted. However, you should
    consider keeping several backup sets to be absolutely certain that
    you can recover your data.
-->
バックアップを使用するためには、ファイルシステムのバックアップ取得中、および、その後に生成されるWALセグメントファイル全てが保存されている必要があります。
この目的のために、ベースバックアップの過程で即座にWALアーカイブ領域に<firstterm>バックアップ履歴ファイル</firstterm>が作成されます。
このファイルにはファイルシステムのバックアップに最初に必要とされるWALセグメントの名前が付けられます。
例えば、最初のWALファイルが <literal>0000000100001234000055CD</literal>である場合、バックアップ履歴ファイルは<literal>0000000100001234000055CD.007C9330.backup</literal>というように名付けられます。
（ファイル名の2番目のパートはWALファイルの厳密な位置が記載されます。通常は無視することができます。）
一旦、安全にファイルシステムのバックアップとそのバックアップ中に使用されたWALセグメントファイル（バックアップ履歴ファイルから特定できます）を取得すると、それより数値の小さな全てのWALアーカイブセグメントはファイルシステムの復旧には必要が無く、削除することができます。
しかし、データを確実に復旧させるためには数世代のバックアップセットを保持することを考慮すべきです。
   </para>

   <para>
<!--
    The backup history file is just a small text file. It contains the
    label string you gave to <xref linkend="app-pgbasebackup"/>, as well as
    the starting and ending times and WAL segments of the backup.
    If you used the label to identify the associated dump file,
    then the archived history file is enough to tell you which dump file to
    restore.
-->
バックアップ履歴ファイルは、ほんの小さなテキストファイルです。
これには<xref linkend="app-pgbasebackup"/>で与えたラベル文字列の他、バックアップの開始、終了時間およびバックアップのWALセグメントが含まれます。
このラベルをバックアップを構成するために使うことで、アーカイブ履歴ファイルはどのバックアップをリストアするべきか間違いなく判断することができます。
   </para>

   <para>
<!--
    Since you have to keep around all the archived WAL files back to your
    last base backup, the interval between base backups should usually be
    chosen based on how much storage you want to expend on archived WAL
    files.  You should also consider how long you are prepared to spend
    recovering, if recovery should be necessary &mdash; the system will have to
    replay all those WAL segments, and that could take awhile if it has
    been a long time since the last base backup.
-->
最後のベースバックアップ以降のWALアーカイブを保持し続ける必要があるため、通常、ベースバックアップを取得すべき期間は、WALアーカイブを保持するためにどのくらいのストレージを拡張できるかによって決定されます。
また、復旧が必要になった場合に、どのくらいの時間を復旧に使うと覚悟するのかも考慮すべきです。&mdash;
システムは全てのWALセグメントを適用する必要があるため、もし、最後のベースバックアップを取得してから長い時間が経過している場合、適用に時間を要する可能性があります。
   </para>
  </sect2>

  <sect2 id="backup-lowlevel-base-backup">
<!--
   <title>Making a Base Backup Using the Low Level API</title>
-->
   <title>低レベルAPIを使用したベースバックアップの作成</title>
   <para>
<!--
    The procedure for making a base backup using the low level
    APIs contains a few more steps than
    the <xref linkend="app-pgbasebackup"/> method, but is relatively
    simple. It is very important that these steps are executed in
    sequence, and that the success of a step is verified before
    proceeding to the next step.
-->
低レベルのAPIを使ったベースバックアップを取得するには<xref linkend="app-pgbasebackup"/> を使う方法に加えて数ステップが必要ですが、比較的簡単です。
これらのステップは順番に実行することが重要で、次のステップに進む前にこれらのステップが成功していることを確認する必要があります。
   </para>
    <para>
<!--
     Multiple backups are able to be run concurrently (both those
     started using this backup API and those started using
     <xref linkend="app-pgbasebackup"/>).
-->
複数のバックアップを同時に実行できます（このバックアップAPIを使用して開始されたバックアップと<xref linkend="app-pgbasebackup"/>を使用して開始されたバックアップの両方）。
    </para>
    <para>
  <orderedlist>
   <listitem>
    <para>
<!--
     Ensure that WAL archiving is enabled and working.
-->
WALアーカイブが有効であり、正常に動作することを確認してください。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     Connect to the server (it does not matter which database) as a user with
     rights to run <function>pg_backup_start</function> (superuser,
     or a user who has been granted <literal>EXECUTE</literal> on the
     function) and issue the command:
-->
<function>pg_backup_start</function>の実行権限を持つユーザとしてサーバ（どのデータベースであってもかまいません）に接続します。ユーザはスーパーユーザか、またはこの関数に<literal>EXECUTE</literal>権限を与えられたユーザです。以下のコマンドを発行します。
<programlisting>
SELECT pg_backup_start(label => 'label', fast => false);
</programlisting>
<!--
     where <literal>label</literal> is any string you want to use to uniquely
     identify this backup operation. The connection
     calling <function>pg_backup_start</function> must be maintained until the end of
     the backup, or the backup will be automatically aborted.
-->
ここで<literal>label</literal>は、このバックアップ操作を一意に識別するために使用したい文字列です。
<function>pg_backup_start</function>を呼び出す接続は、バックアップが終了するまで維持されなければなりません。
さもないと、バックアップは自動的に打ち切られます。
    </para>

    <para>
<!--
     Online backups are always started at the beginning of a checkpoint.
     By default, <function>pg_backup_start</function> will wait for the next
     regularly scheduled checkpoint to complete, which may take a long time (see the
     configuration parameters <xref linkend="guc-checkpoint-timeout"/> and
     <xref linkend="guc-checkpoint-completion-target"/>).  This is
     usually preferable as it minimizes the impact on the running system.  If you
     want to start the backup as soon as possible, pass <literal>true</literal> as
     the second parameter to <function>pg_backup_start</function> and it will
     request an immediate checkpoint, which will finish as fast as possible using
     as much I/O as possible.
-->
オンラインバックアップは、常にチェックポイントの先頭から開始されます。
デフォルトでは、<function>pg_backup_start</function>は、次の定期的にスケジュールされたチェックポイントが完了するまで待機します。
これには長い時間がかかる場合があります（設定パラメータ<xref linkend="guc-checkpoint-timeout"/>および<xref linkend="guc-checkpoint-completion-target"/>を参照してください）。
これは、実行中のシステムへの影響を最小限に抑えるため、通常は望ましい方法です。
できるだけ早くバックアップを開始したい場合は、<function>pg_backup_start</function>の2番目のパラメータとして<literal>true</literal>を渡すと、即時のチェックポイントが要求されます。
このチェックポイントは、できるだけ多くのI/Oを使用してできるだけ早く完了します。
    </para>

   </listitem>
   <listitem>
    <para>
<!--
     Perform the backup, using any convenient file-system-backup tool
     such as <application>tar</application> or <application>cpio</application> (not
     <application>pg_dump</application> or
     <application>pg_dumpall</application>).  It is neither
     necessary nor desirable to stop normal operation of the database
     while you do this. See
     <xref linkend="backup-lowlevel-base-backup-data"/> for things to
     consider during this backup.
-->
（<application>pg_dump</application>や<application>pg_dumpall</application>ではなく）<application>tar</application>や<application>cpio</application>などの使い慣れた任意のファイルシステムバックアップツールを使用して、バックアップを実行してください。
この作業時に、データベースの通常の操作を停止することは不要ですし、望ましい方法でもありません。
このバックアップの実行中に考慮すべき点は<xref linkend="backup-lowlevel-base-backup-data"/>を参照してください。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     In the same connection as before, issue the command:
-->
以前と同じ接続の中で、以下のコマンドを実行します。
<programlisting>
SELECT * FROM pg_backup_stop(wait_for_archive => true);
</programlisting>
<!--
     This terminates backup mode. On a primary, it also performs an automatic
     switch to the next WAL segment.  On a standby, it is not possible to
     automatically switch WAL segments, so you may wish to run
     <function>pg_switch_wal</function> on the primary to perform a manual
     switch. The reason for the switch is to arrange for
     the last WAL segment file written during the backup interval to be
     ready to archive.
-->
これはバックアップモードを終了し、プライマリでは、次のWALセグメントへの自動切換えを行います。
スタンバイでは、WALセグメントを自動的に切り替えることはできません。
ですから、手動切り替えを行うためにプライマリで<function>pg_switch_wal</function>を実行することをお勧めします。
この切換えの理由は、バックアップ期間中に書き出された最後のWALファイルがアーカイブできるよう準備することです。
    </para>
    <para>
<!--
     <function>pg_backup_stop</function> will return one row with three
     values. The second of these fields should be written to a file named
     <filename>backup_label</filename> in the root directory of the backup. The
     third field should be written to a file named
     <filename>tablespace_map</filename> unless the field is empty. These files are
     vital to the backup working and must be written byte for byte without
     modification, which may require opening the file in binary mode.
-->
<function>pg_backup_stop</function>は3つの値を含んだ1行を返します。
2番目の値は、バックアップのルートディレクトリ内の<filename>backup_label</filename>という名称のファイルを作成の上、値を書き込む必要があります。
3番目の値は、空でない限りは<filename>tablespace_map</filename>という名称のファイルを作成の上、値を書き込む必要があります。
これらのファイルはバックアップが動作するために極めて重要であり、1バイトも変更なしに書き込まれる必要があるため、バイナリモードで開かれる必要があるかもしれません。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     Once the WAL segment files active during the backup are archived, you are
     done.  The file identified by <function>pg_backup_stop</function>'s first return
     value is the last segment that is required to form a complete set of
     backup files.  On a primary, if <varname>archive_mode</varname> is enabled and the
     <literal>wait_for_archive</literal> parameter is <literal>true</literal>,
     <function>pg_backup_stop</function> does not return until the last segment has
     been archived.
     On a standby, <varname>archive_mode</varname> must be <literal>always</literal> in order
     for <function>pg_backup_stop</function> to wait.
     Archiving of these files happens automatically since you have
     already configured <varname>archive_command</varname> or <varname>archive_library</varname>.
     In most cases this happens quickly, but you are advised to monitor your
     archive system to ensure there are no delays.
     If the archive process has fallen behind because of failures of the
     archive command or library, it will keep retrying
     until the archive succeeds and the backup is complete.
     If you wish to place a time limit on the execution of
     <function>pg_backup_stop</function>, set an appropriate
     <varname>statement_timeout</varname> value, but make note that if
     <function>pg_backup_stop</function> terminates because of this your backup
     may not be valid.
-->
バックアップ中に使用されたWALセグメントファイルがアーカイブされれば完了です。
<function>pg_backup_stop</function>の返り値の1番目の値で識別されるファイルは、バックアップファイル一式を完結させるのに必要となる最終セグメントです。
プライマリでは、<varname>archive_mode</varname>が有効で、かつ<literal>wait_for_archive</literal>パラメータが<literal>true</literal>であれば、<function>pg_backup_stop</function> は最終セグメントがアーカイブされるまで戻りません。
スタンバイでは、<function>pg_backup_stop</function>がアーカイブ完了を待つためには、<varname>archive_mode</varname>は<literal>always</literal>でなければなりません。
すでに<varname>archive_command</varname>あるいは<varname>archive_library</varname>を設定していますので、これらのファイルのアーカイブ操作は自動的に発生します。
ほとんどの場合、これは瞬時に行われます。
しかし、バックアップの完了を確認できるよう、アーカイブシステムを監視し、遅延が無いことの確認をお勧めします。
アーカイブコマンドの失敗によりアーカイブ処理が遅れてしまったとしても、アーカイブが成功し、そしてバックアップが完了するまで再試行を繰り返すようになっています。
<function>pg_backup_stop</function>実行においての時間期限を設けたい場合、適切な<varname>statement_timeout</varname>の値を設定できますが、この設定値によって<function>pg_backup_stop</function>が中断したときにバックアップが正当ではない可能性があるということを肝に銘じてください。
    </para>
    <para>
<!--
     If the backup process monitors and ensures that all WAL segment files
     required for the backup are successfully archived then the
     <literal>wait_for_archive</literal> parameter (which defaults to true) can be set
     to false to have
     <function>pg_backup_stop</function> return as soon as the stop backup record is
     written to the WAL.  By default, <function>pg_backup_stop</function> will wait
     until all WAL has been archived, which can take some time.  This option
     must be used with caution: if WAL archiving is not monitored correctly
     then the backup might not include all of the WAL files and will
     therefore be incomplete and not able to be restored.
-->
バックアップに必要なすべてのWALセグメントファイルのアーカイブが成功したことを、バックアップ作業の中で監視して確認するのであれば、<literal>wait_for_archive</literal>パラメータ(デフォルトでtrueです)をfalseに設定し、バックアップレコードがWALに書き込まれたら即座に<function>pg_backup_stop</function>が戻るようにすることができます。
デフォルトでは、<function>pg_backup_stop</function>はすべてのWALがアーカイブされるのを待つので、少し時間がかかることがあります。
このオプションは慎重に使わなければなりません。
WALのアーカイブを適切に監視していない場合、バックアップにはすべてのWALファイルが含まれず、不完全かもしれません。
そうなると、リストアできません。
    </para>
   </listitem>
  </orderedlist>
    </para>
   <sect3 id="backup-lowlevel-base-backup-data">
<!--
   <title>Backing Up the Data Directory</title>
-->
   <title>データディレクトリのバックアップ</title>
   <para>
<!--
    Some file system backup tools emit warnings or errors
    if the files they are trying to copy change while the copy proceeds.
    When taking a base backup of an active database, this situation is normal
    and not an error.  However, you need to ensure that you can distinguish
    complaints of this sort from real errors.  For example, some versions
    of <application>rsync</application> return a separate exit code for
    <quote>vanished source files</quote>, and you can write a driver script to
    accept this exit code as a non-error case.  Also, some versions of
    GNU <application>tar</application> return an error code indistinguishable from
    a fatal error if a file was truncated while <application>tar</application> was
    copying it.  Fortunately, GNU <application>tar</application> versions 1.16 and
    later exit with 1 if a file was changed during the backup,
    and 2 for other errors.  With GNU <application>tar</application> version 1.23 and
    later, you can use the warning options <literal>&#45;-warning=no-file-changed
    &#45;-warning=no-file-removed</literal> to hide the related warning messages.
-->
ファイルシステムのバックアップツール中には複写している途中でファイルが変更されると警告もしくはエラーを報告するものがあります。
稼働しているデータベースのベースバックアップを取っている場合には、この状況は正常でエラーではありません。
しかし、この種の警告と本当のエラーとを区別できるか確認が必要です。
例えば、<application>rsync</application>のバージョンによっては<quote>消滅したソースファイル</quote>に対して別の終了コードを返し、そしてこの終了コードをエラーではないと受け付けるドライバスクリプトを記述することができます。
同時にGNU <application>tar</application>のバージョンによっては、<application>tar</application>がそれを複写していた途中でファイルが切り詰められると、致命的エラーと識別できないエラーコードを返します。
ありがたいことに、GNU <application>tar</application>のバージョン1.16もしくはそれ以降では、バックアップ中にファイルが変更されると1で、それ以外のエラーの時は2でプログラムから抜けます。
GNUの <application>tar</application>で1.23以降のバージョンを使用しているのであれば、<literal>--warning=no-file-changed --warning=no-file-removed</literal>オプションをつけることで関連する警告メッセージを隠すオプションを使用することができます。
   </para>

   <para>
<!--
    Be certain that your backup includes all of the files under
    the database cluster directory (e.g., <filename>/usr/local/pgsql/data</filename>).
    If you are using tablespaces that do not reside underneath this directory,
    be careful to include them as well (and be sure that your backup
    archives symbolic links as links, otherwise the restore will corrupt
    your tablespaces).
-->
バックアップに、データベースクラスタディレクトリ（例えば<filename>/usr/local/pgsql/data</filename>）以下にある全てのファイルが含まれていることを確認してください。
このディレクトリ以下に存在しないテーブル空間を使用している場合、注意して、同様にそれらを含めてください
（そして、バックアップがリンクとしてシンボリックリンクをアーカイブしていることを確認してください。
さもないとリストアはテーブル空間を壊してしまいます）。
   </para>

   <para>
<!--
    You should, however, omit from the backup the files within the
    cluster's <filename>pg_wal/</filename> subdirectory.  This
    slight adjustment is worthwhile because it reduces the risk
    of mistakes when restoring.  This is easy to arrange if
    <filename>pg_wal/</filename> is a symbolic link pointing to someplace outside
    the cluster directory, which is a common setup anyway for performance
    reasons.  You might also want to exclude <filename>postmaster.pid</filename>
    and <filename>postmaster.opts</filename>, which record information
    about the running <application>postmaster</application>, not about the
    <application>postmaster</application> which will eventually use this backup.
    (These files can confuse <application>pg_ctl</application>.)
-->
しかし、クラスタの<filename>pg_wal/</filename>サブディレクトリにあるファイルをバックアップから省いてください。
このちょっとした調整は、リストア処理中の失敗の危険性を低減できますので、行う価値があります。
<filename>pg_wal/</filename>がクラスタディレクトリ外のどこかを指し示すシンボリックリンクの場合は調整が簡単です。
これは性能上の理由でよく使用される設定です。
また、いずれこのバックアップを使う<application>postmaster</application>ではなく、今起動している<application>postmaster</application>の情報を記録している<filename>postmaster.pid</filename>と<filename>postmaster.opts</filename>も除外できます。
(これらのファイルは<application>pg_ctl</application>を誤作動させる可能性があります。)
   </para>

   <para>
<!--
    It is often a good idea to also omit from the backup the files
    within the cluster's <filename>pg_replslot/</filename> directory, so that
    replication slots that exist on the primary do not become part of the
    backup.  Otherwise, the subsequent use of the backup to create a standby
    may result in indefinite retention of WAL files on the standby, and
    possibly bloat on the primary if hot standby feedback is enabled, because
    the clients that are using those replication slots will still be connecting
    to and updating the slots on the primary, not the standby.  Even if the
    backup is only intended for use in creating a new primary, copying the
    replication slots isn't expected to be particularly useful, since the
    contents of those slots will likely be badly out of date by the time
    the new primary comes on line.
-->
プライマリ上に存在するレプリケーションスロットがバックアップに含まれないようにするために、クラスタの中の<filename>pg_replslot/</filename>ディレクトリをバックアップから除くのもしばしば良い考えです。
もし、スタンバイを作成するためのバックアップを続けて使用すると、スタンバイのWALファイルの保持を無制限に保留する結果になり、ホットスタンバイからのフィードバックを有効にしている場合、プライマリのWALを膨張させます。
これは、これらのレプリケーションスロットを使っているクライアントはまだ、スタンバイではなく、プライマリのスロットを接続し続け、更新しているからです。
バックアップが新しいプライマリを作成するためだけに作成されたとしても、レプリケーションスロットをコピーすることは特に有益であるとは考えられません。
このようにバックアップにレプリケーションスロットを含むことは、新しいプライマリがオンラインになったときにはスロットの内容が期限切れしており、有害である可能性があります。
   </para>

   <para>
<!--
    The contents of the directories <filename>pg_dynshmem/</filename>,
    <filename>pg_notify/</filename>, <filename>pg_serial/</filename>,
    <filename>pg_snapshots/</filename>, <filename>pg_stat_tmp/</filename>,
    and <filename>pg_subtrans/</filename> (but not the directories themselves) can be
    omitted from the backup as they will be initialized on postmaster startup.
-->
ディレクトリ<filename>pg_dynshmem/</filename>、<filename>pg_notify/</filename>、<filename>pg_serial/</filename>、<filename>pg_snapshots/</filename>、<filename>pg_stat_tmp/</filename>、<filename>pg_subtrans/</filename>の中身はバックアップから除外できます。（ただし、ディレクトリ自体は除外できません。）
というのも、postmaster起動時に初期化されるからです。
   </para>

   <para>
<!--
    Any file or directory beginning with <filename>pgsql_tmp</filename> can be
    omitted from the backup.  These files are removed on postmaster start and
    the directories will be recreated as needed.
-->
<filename>pgsql_tmp</filename>で始まるすべてのファイルとディレクトリはバックアップから除外できます。
これらのファイルはpostmasterの起動時に削除されますし、ディレクトリも必要なら再作成されます。
   </para>

   <para>
<!--
    <filename>pg_internal.init</filename> files can be omitted from the
    backup whenever a file of that name is found.  These files contain
    relation cache data that is always rebuilt when recovering.
-->
<filename>pg_internal.init</filename>という名前のファイルが見つかった場合、それはバックアップから省くことができます。
このファイルはリレーションキャッシュデータを含んでおり、常にリカバリの際に再構築されます。
   </para>

   <para>
<!--
    The backup label
    file includes the label string you gave to <function>pg_backup_start</function>,
    as well as the time at which <function>pg_backup_start</function> was run, and
    the name of the starting WAL file.  In case of confusion it is therefore
    possible to look inside a backup file and determine exactly which
    backup session the dump file came from.  The tablespace map file includes
    the symbolic link names as they exist in the directory
    <filename>pg_tblspc/</filename> and the full path of each symbolic link.
    These files are not merely for your information; their presence and
    contents are critical to the proper operation of the system's recovery
    process.
-->
バックアップラベルファイルには、<function>pg_backup_start</function>に付与したラベル文字列と<function>pg_backup_start</function>が実行された時刻、最初のWALファイルの名前が含まれます。
したがって、当惑した時にバックアップファイルの中身を検索し、そのダンプファイルがどのバックアップセッションに由来したものかを確認することができます。
テーブル空間マップファイルにはディレクトリ<filename>pg_tblspc/</filename>に存在するシンボリックリンク名と各シンボリックリンクのフルパスが含まれています。
このファイルはあなたのためだけの情報ではありません。
その存在と内容はシステムのリカバリプロセスが適切に動作するために非常に重要です。
   </para>

   <para>
<!--
    It is also possible to make a backup while the server is
    stopped.  In this case, you obviously cannot use
    <function>pg_backup_start</function> or <function>pg_backup_stop</function>, and
    you will therefore be left to your own devices to keep track of which
    backup is which and how far back the associated WAL files go.
    It is generally better to follow the continuous archiving procedure above.
-->
サーバが停止している時にバックアップを作成することも可能です。
この場合、わかりきったことですが、<function>pg_backup_start</function>や<function>pg_backup_stop</function>を使用することができません。
そのため、どのバックアップが、どのWALファイルと関連し、どこまで戻せばよいかを独自の方法で残さなければなりません。
通常は、上述の継続的アーカイブ手順に従う方をお勧めします。
   </para>
   </sect3>
  </sect2>

  <sect2 id="backup-pitr-recovery">
<!--
   <title>Recovering Using a Continuous Archive Backup</title>
-->
   <title>継続的アーカイブによるバックアップを使用した復旧</title>

   <para>
<!--
    Okay, the worst has happened and you need to recover from your backup.
    Here is the procedure:
-->
さて、最悪の事態が発生し、バックアップから復旧する必要が出てきたものとします。
以下にその手順を説明します。
  <orderedlist>
   <listitem>
    <para>
<!--
     Stop the server, if it's running.
-->
もし稼動しているのであればサーバを停止してください。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     If you have the space to do so,
     copy the whole cluster data directory and any tablespaces to a temporary
     location in case you need them later. Note that this precaution will
     require that you have enough free space on your system to hold two
     copies of your existing database. If you do not have enough space,
     you should at least save the contents of the cluster's <filename>pg_wal</filename>
     subdirectory, as it might contain logs which
     were not archived before the system went down.
-->
もし容量があるのであれば、後で必要になる場合に備えてクラスタデータディレクトリ全体とテーブル空間を全て一時的な場所にコピーしてください。
この予防措置は、既存のデータベースを2つ分保持できるだけの空き領域を必要とします。
十分な領域がない場合でも、少なくともクラスタの<filename>pg_wal</filename>サブディレクトリの内容は保存すべきです。
ここには、システムが停止する前にアーカイブされなかったログファイルが含まれているかも知れないからです。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     Remove all existing files and subdirectories under the cluster data
     directory and under the root directories of any tablespaces you are using.
-->
クラスタデータディレクトリ以下、および、使用中のテーブル空間の最上位ディレクトリ以下にある既存の全てのファイルとサブディレクトリを削除してください。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     Restore the database files from your file system backup.  Be sure that they
     are restored with the right ownership (the database system user, not
     <literal>root</literal>!) and with the right permissions.  If you are using
     tablespaces,
     you should verify that the symbolic links in <filename>pg_tblspc/</filename>
     were correctly restored.
-->
ファイルシステムバックアップからデータベースファイルをリストアします。
ファイルが正しい所有権（<literal>root</literal>ではなくデータベースシステムユーザです！）でリストアされていることを確認してください。
テーブル空間を使用している場合は、<filename>pg_tblspc/</filename>内のシンボリックリンクが正しくリストアされていることを検証する必要があります。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     Remove any files present in <filename>pg_wal/</filename>; these came from the
     file system backup and are therefore probably obsolete rather than current.
     If you didn't archive <filename>pg_wal/</filename> at all, then recreate
     it with proper permissions,
     being careful to ensure that you re-establish it as a symbolic link
     if you had it set up that way before.
-->
<filename>pg_wal/</filename>内にあるファイルをすべて削除してください。
これらはファイルシステムバックアップから生成されたものであり、おそらく現在のものより古く使用できないものです。
<filename>pg_wal/</filename>をまったくアーカイブしていなければ、適切な権限で再作成してください。
以前シンボリックリンクとして設定していたのであれば、そのように確実に再構築するように注意してください。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     If you have unarchived WAL segment files that you saved in step 2,
     copy them into <filename>pg_wal/</filename>.  (It is best to copy them,
     not move them, so you still have the unmodified files if a
     problem occurs and you have to start over.)
-->
手順2で退避させた未アーカイブのWALセグメントファイルがあるのであれば、<filename>pg_wal/</filename>にコピーしてください。
（問題が発生し、初めからやり直さなければならない場合に未変更のファイルが残るように、移動させるのではなくコピーすることが最善です。）
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     Set recovery configuration settings in
     <filename>postgresql.conf</filename> (see <xref
     linkend="runtime-config-wal-archive-recovery"/>) and create a file
     <filename>recovery.signal</filename> in the cluster
     data directory. You might
     also want to temporarily modify <filename>pg_hba.conf</filename> to prevent
     ordinary users from connecting until you are sure the recovery was successful.
-->
<filename>postgresql.conf</filename>（<xref linkend="runtime-config-wal-archive-recovery"/>を参照してください）に復旧の設定を記述し、クラスタデータディレクトリに<filename>recovery.signal</filename>ファイルを作成します。
また、一時的に<filename>pg_hba.conf</filename>を変更し、復旧の成功を確認できるまで一般ユーザが接続できないようにする必要があるかもしれません。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     Start the server.  The server will go into recovery mode and
     proceed to read through the archived WAL files it needs.  Should the
     recovery be terminated because of an external error, the server can
     simply be restarted and it will continue recovery.  Upon completion
     of the recovery process, the server will remove
     <filename>recovery.signal</filename> (to prevent
     accidentally re-entering recovery mode later) and then
     commence normal database operations.
-->
サーバを起動してください。
サーバは復旧モードに入り、必要なアーカイブ済みWALファイル群の読み込みを行います。
外部的なエラーにより復旧が中断したら、サーバを単に再起動させて、復旧処理を継続してください。
復旧処理が完了したら、（誤って後で復旧モードに再度入らないように）サーバは<filename>recovery.signal</filename>を削除します。
その後通常のデータベース操作を開始します。
    </para>
   </listitem>
   <listitem>
    <para>
<!--
     Inspect the contents of the database to ensure you have recovered to
     the desired state.  If not, return to step 1.  If all is well,
     allow your users to connect by restoring <filename>pg_hba.conf</filename> to normal.
-->
データベースの内容を検査し、希望する状態まで復旧できていることを確認してください。
復旧できなかった場合は手順1に戻ってください。
全て問題なければ、ユーザが接続できるように<filename>pg_hba.conf</filename>を正常状態に戻してください。
    </para>
   </listitem>
  </orderedlist>
   </para>

   <para>
<!--
    The key part of all this is to set up a recovery configuration that
    describes how you want to recover and how far the recovery should
    run.  The one thing that you absolutely must specify is the <varname>restore_command</varname>,
    which tells <productname>PostgreSQL</productname> how to retrieve archived
    WAL file segments.  Like the <varname>archive_command</varname>, this is
    a shell command string.  It can contain <literal>%f</literal>, which is
    replaced by the name of the desired log file, and <literal>%p</literal>,
    which is replaced by the path name to copy the log file to.
    (The path name is relative to the current working directory,
    i.e., the cluster's data directory.)
    Write <literal>%%</literal> if you need to embed an actual <literal>%</literal>
    character in the command.  The simplest useful command is
    something like:
-->
ここで重要となるのは、どのように復旧させたいのかやどこまで復旧させたいかを記述する復旧設定を設定することです。
絶対に指定しなければならないことは、アーカイブ済みWALファイルセグメントをどのように戻すかを<productname>PostgreSQL</productname>に通知する<varname>restore_command</varname>です。
<varname>archive_command</varname>同様、これはシェルコマンド文字列です。
ここには、対象のログファイルの名前で置換される<literal>%f</literal>やログファイルのコピー先を示すパスで置換される<literal>%p</literal>を含めることができます。
（パス名は現在の作業用ディレクトリ、つまり、クラスタのデータディレクトリから見た相対パスです。）
コマンド内に<literal>%</literal>文字自体を埋め込む必要があれば<literal>%%</literal>と記載してください。
最も簡単でよく使われるコマンドは以下のようなものです。
<programlisting>
restore_command = 'cp /mnt/server/archivedir/%f %p'
</programlisting>
<!--
    which will copy previously archived WAL segments from the directory
    <filename>/mnt/server/archivedir</filename>.  Of course, you can use something
    much more complicated, perhaps even a shell script that requests the
    operator to mount an appropriate tape.
-->
これは事前にアーカイブされたWALセグメントを<filename>/mnt/server/archivedir</filename>ディレクトリからコピーします。
当然ながら、もっと複雑なものを使用することができます。
例えば、操作者に適切なテープをマウントさせることを要求するようなシェルスクリプトでさえ可能です。
   </para>

   <para>
<!--
    It is important that the command return nonzero exit status on failure.
    The command <emphasis>will</emphasis> be called requesting files that are not
    present in the archive; it must return nonzero when so asked.  This is not
    an error condition.  An exception is that if the command was terminated by
    a signal (other than <systemitem>SIGTERM</systemitem>, which is used as
    part of a database server shutdown) or an error by the shell (such as
    command not found), then recovery will abort and the server will not start
    up.
-->
このコマンドが失敗した時に非ゼロの終了ステータスを返すことが重要です。
このコマンドは、アーカイブに存在しないファイルを要求する<emphasis>かもしれません</emphasis>が、その場合でも非ゼロを返さなければなりません。
これはエラー状態ではありません。
例外は、コマンドがシグナルによって中断された場合(データベースの停止に使用される<systemitem>SIGTERM</systemitem>以外)か、シェルによるエラー(コマンドが見つかりませんなど)で復旧が中断され、サーバが起動しない場合です。
   </para>

   <para>
<!--
    Not all of the requested files will be WAL segment
    files; you should also expect requests for files with a suffix of
    <literal>.history</literal>. Also be aware that
    the base name of the <literal>%p</literal> path will be different from
    <literal>%f</literal>; do not expect them to be interchangeable.
-->
要求されるファイルはWALセグメントファイルだけではありません。
<literal>.history</literal>が付いているファイルが要求されることも想定しなければなりません。
同時に、<literal>%p</literal>パスのファイル名部分は<literal>%f</literal>と異なることに注意してください。
これらが相互に置き換え可能であるとは考えないでください。
   </para>

   <para>
<!--
    WAL segments that cannot be found in the archive will be sought in
    <filename>pg_wal/</filename>; this allows use of recent un-archived segments.
    However, segments that are available from the archive will be used in
    preference to files in <filename>pg_wal/</filename>.
-->
アーカイブ場所で見つけられなかったWALセグメントは<filename>pg_wal/</filename>から検索されます。
これにより、最近の未アーカイブのセグメントを使用することができます。
しかし、アーカイブ場所から利用できるセグメントは<filename>pg_wal/</filename>内のファイルよりも優先的に使用されます。
   </para>

   <para>
<!--
    Normally, recovery will proceed through all available WAL segments,
    thereby restoring the database to the current point in time (or as
    close as possible given the available WAL segments).  Therefore, a normal
    recovery will end with a <quote>file not found</quote> message, the exact text
    of the error message depending upon your choice of
    <varname>restore_command</varname>.  You may also see an error message
    at the start of recovery for a file named something like
    <filename>00000001.history</filename>.  This is also normal and does not
    indicate a problem in simple recovery situations; see
    <xref linkend="backup-timelines"/> for discussion.
-->
通常は利用可能な全てのWALセグメントを使用して復旧処理が行われます。
その結果、データベースを現時点まで（もしくは、利用可能なWALセグメントで得られる限り現在に近い時点まで）リストアします。
従って、通常の復旧は<quote>file not found</quote>メッセージで終了します。
エラーメッセージの正確な文言は<varname>restore_command</varname>の選択によります。
また、復旧の開始時点で<filename>00000001.history</filename>のようなファイル名のエラーメッセージが出ることがあります。
これも単純な復旧作業では不具合を意味するものでなく正常です。
論議については<xref linkend="backup-timelines"/>を参照してください。
   </para>

   <para>
<!--
    If you want to recover to some previous point in time (say, right before
    the junior DBA dropped your main transaction table), just specify the
    required <link linkend="runtime-config-wal-recovery-target">stopping point</link>.  You can specify
    the stop point, known as the <quote>recovery target</quote>, either by
    date/time, named restore point or by completion of a specific transaction
    ID.  As of this writing only the date/time and named restore point options
    are very usable, since there are no tools to help you identify with any
    accuracy which transaction ID to use.
-->
もし以前のある時点まで復旧させたい場合（例えば、経験不足のデータベース管理者が主トランザクションテーブルを消去した直前）、要求する<link linkend="runtime-config-wal-recovery-target">停止時点</link>を指定するだけです。
停止時点は、<quote>recovery target</quote>として既知の停止時点で指定することも、日付と時刻で指定することも、リストアポイントか完了した特定のトランザクションIDで指定することもできます。
本ドキュメントの執筆時点では使用するトランザクションIDの識別を補助するツールがありませんので、ほとんどの場合は日付と時刻による指定のみを使用することになるでしょう。
   </para>

   <note>
     <para>
<!--
      The stop point must be after the ending time of the base backup, i.e.,
      the end time of <function>pg_backup_stop</function>.  You cannot use a base backup
      to recover to a time when that backup was in progress.  (To
      recover to such a time, you must go back to your previous base backup
      and roll forward from there.)
-->
停止時点はバックアップの終了時刻、つまり、<function>pg_backup_stop</function>の最終時刻より後の時点でなければなりません。
バックアップを行っている最中のある時点までベースバックアップを使用して復旧させることはできません
（こうした時点まで復旧させるには、その前のベースバックアップまで戻って、そこからロールフォワードしてください）。
     </para>
   </note>

   <para>
<!--
    If recovery finds corrupted WAL data, recovery will
    halt at that point and the server will not start. In such a case the
    recovery process could be re-run from the beginning, specifying a
    <quote>recovery target</quote> before the point of corruption so that recovery
    can complete normally.
    If recovery fails for an external reason, such as a system crash or
    if the WAL archive has become inaccessible, then the recovery can simply
    be restarted and it will restart almost from where it failed.
    Recovery restart works much like checkpointing in normal operation:
    the server periodically forces all its state to disk, and then updates
    the <filename>pg_control</filename> file to indicate that the already-processed
    WAL data need not be scanned again.
-->
復旧時にWALデータの破損がわかると、復旧はその時点で止まり、サーバは起動しません。
こうした場合、<quote>復旧対象</quote>に破損時点より前の時点を指定することで、復旧処理が正常に完了できるよう、復旧プロセスを初めからやり直すことができます。
システムクラッシュなど外的理由により復旧処理が失敗した場合やWALアーカイブがアクセスできなくなった場合、復旧処理を単に再起動させることができます。
この場合は失敗した時点とほぼ同じところから再開します。
復旧処理の再起動は、次のような通常操作時のチェックポイント処理とほぼ同様に動作します。
サーバは定期的にすべての状態をディスクに強制し、再度スキャンする必要がない処理済みのWALデータを示す<filename>pg_control</filename>ファイルを更新します。
   </para>

  </sect2>

  <sect2 id="backup-timelines">
<!--
   <title>Timelines</title>
-->
   <title>タイムライン</title>

  <indexterm zone="backup">
   <primary>timelines</primary>
  </indexterm>
  <indexterm zone="backup">
   <primary>タイムライン</primary>
  </indexterm>

   <para>
<!--
    The ability to restore the database to a previous point in time creates
    some complexities that are akin to science-fiction stories about time
    travel and parallel universes.  For example, in the original history of the database,
    suppose you dropped a critical table at 5:15PM on Tuesday evening, but
    didn't realize your mistake until Wednesday noon.
    Unfazed, you get out your backup, restore to the point-in-time 5:14PM
    Tuesday evening, and are up and running.  In <emphasis>this</emphasis> history of
    the database universe, you never dropped the table.  But suppose
    you later realize this wasn't such a great idea, and would like
    to return to sometime Wednesday morning in the original history.
    You won't be able
    to if, while your database was up-and-running, it overwrote some of the
    WAL segment files that led up to the time you now wish you
    could get back to.  Thus, to avoid this, you need to distinguish the series of
    WAL records generated after you've done a point-in-time recovery from
    those that were generated in the original database history.
-->
過去のある時点までデータベースを復旧できる機能は、タイムトラベルやパラレルユニバースといったSFの物語に類似した、多少の複雑性があります。
例えば、データベースの元の履歴で、火曜日の夕方5:15PMに重要なテーブルを削除し、水曜日のお昼まで手違いに気が付かなかったとします。
慌てずに、バックアップを取り出して、火曜日の夕方5:14PMの時点にリストアし、データベースを起動させます。
データベース世界の<emphasis>この</emphasis>履歴では、そのテーブルを削除していません。
しかし、後になって、これは大した問題ではなかったことが分かり、元の履歴における水曜日に朝の何時かにまで戻したいと考えたと仮定しましょう。
データベースは既に起動していますので、元に戻したい時点に至るWALセグメントファイルの一部は上書きされていて、戻すことはできないかもしれません。
ですので、このことを避けるために、ポイントインタイムで復旧させた後に生成された一連のWAL記録と元のデータベースの履歴において生成されたWAL記録とを区別する必要があります。
   </para>

   <para>
<!--
    To deal with this problem, <productname>PostgreSQL</productname> has a notion
    of <firstterm>timelines</firstterm>.  Whenever an archive recovery completes,
    a new timeline is created to identify the series of WAL records
    generated after that recovery.  The timeline
    ID number is part of WAL segment file names so a new timeline does
    not overwrite the WAL data generated by previous timelines.  It is
    in fact possible to archive many different timelines.  While that might
    seem like a useless feature, it's often a lifesaver.  Consider the
    situation where you aren't quite sure what point-in-time to recover to,
    and so have to do several point-in-time recoveries by trial and error
    until you find the best place to branch off from the old history.  Without
    timelines this process would soon generate an unmanageable mess.  With
    timelines, you can recover to <emphasis>any</emphasis> prior state, including
    states in timeline branches that you abandoned earlier.
-->
こうした問題を扱うために<productname>PostgreSQL</productname>には<firstterm>タイムライン</firstterm>という概念があります。
アーカイブ復旧が完了したときはいつでも、その復旧後に生成されたWAL記録を識別するための新しいタイムラインが生成されます。
タイムラインID番号はWALセグメントファイル名の一部です。
ですので、新しいタイムラインはこれまでのタイムラインで生成されたWALデータを上書きしません。
実際、多くの異なるタイムラインをアーカイブすることができます。
不要な機能と考えるかもしれませんが、命綱になることがしばしばあります。
どの時点まで復旧すればよいか確実でないといった状況を考えてみてください。
その時は、過去の履歴からの分岐点として最善の時点を見つけるために、試行錯誤して何度もポイントインタイムの復旧を行う必要があるでしょう。
タイムラインがないと、この手続きはすぐに管理不能な混乱を招いてしまいます。
タイムラインを使用して、以前捨てたタイムライン分岐における状態を含む、過去の<emphasis>任意</emphasis>の状態に復旧させることができます。
   </para>

   <para>
<!--
    Every time a new timeline is created, <productname>PostgreSQL</productname> creates
    a <quote>timeline history</quote> file that shows which timeline it branched
    off from and when.  These history files are necessary to allow the system
    to pick the right WAL segment files when recovering from an archive that
    contains multiple timelines.  Therefore, they are archived into the WAL
    archive area just like WAL segment files.  The history files are just
    small text files, so it's cheap and appropriate to keep them around
    indefinitely (unlike the segment files which are large).  You can, if
    you like, add comments to a history file to record your own notes about
    how and why this particular timeline was created.  Such comments will be
    especially valuable when you have a thicket of different timelines as
    a result of experimentation.
-->
新しいタイムラインが生成される度に、<productname>PostgreSQL</productname>は、どのタイムラインがいつどこから分岐したかを示す<quote>タイムライン履歴</quote>ファイルを作成します。
この履歴ファイルは、複数のタイムラインを含むアーカイブ場所から復旧する時にシステムが正しいWALセグメントファイルを選択できるようにするために必要です。
したがって、履歴ファイルは、WALセグメントファイル同様にWALアーカイブ領域にアーカイブされます。
履歴ファイルは（巨大になるセグメントファイルとは異なり）単なる小さなテキストファイルですので、安価かつ適切に無期限で保管できます。
必要ならば、履歴ファイルにコメントを追加し、この特定のタイムラインがどのように、なぜ生成されたかについて独自の注釈を付与することができます。
特にこうしたコメントは、実験の結果いくつものタイムラインのもつれがある場合に有用です。
   </para>

   <para>
<!--
    The default behavior of recovery is to recover to the latest timeline found
    in the archive. If you wish to recover to the timeline that was current
    when the base backup was taken or into a specific child timeline (that
    is, you want to return to some state that was itself generated after a
    recovery attempt), you need to specify <literal>current</literal> or the
    target timeline ID in <xref linkend="guc-recovery-target-timeline"/>. You
    cannot recover into timelines that branched off earlier than the base backup.
-->
復旧処理のデフォルトは、アーカイブで見つかった最新のタイムラインへの復旧です。
ベースバックアップが取得された時点のタイムラインと同一のタイムラインや別の子タイムラインに沿って復旧させたい（つまり、復旧試行以降に生成されたある状態に戻りたい）場合は、<literal>current</literal>か<xref linkend="guc-recovery-target-timeline"/>で対象のタイムラインIDを指定しなければなりません。
ベースバックアップより前に分岐したタイムラインに沿って復旧することはできません。
   </para>
  </sect2>

  <sect2 id="backup-tips">
<!--
   <title>Tips and Examples</title>
-->
   <title>ヒントと例</title>

   <para>
<!--
    Some tips for configuring continuous archiving are given here.
-->
継続的アーカイブを構成するいくつかのヒントを以下にあげます。
   </para>

    <sect3 id="backup-standalone">
<!--
     <title>Standalone Hot Backups</title>
-->
     <title>スタンドアローンホットバックアップ</title>

     <para>
<!--
      It is possible to use <productname>PostgreSQL</productname>'s backup facilities to
      produce standalone hot backups. These are backups that cannot be used
      for point-in-time recovery, yet are typically much faster to backup and
      restore than <application>pg_dump</application> dumps.  (They are also much larger
      than <application>pg_dump</application> dumps, so in some cases the speed advantage
      might be negated.)
-->
スタンドアローンホットバックアップを形成するため<productname>PostgreSQL</productname>のバックアップ基盤を使用することができます。
これらのバックアップはポイントインタイムリカバリに使用することはできないのですが、<application>pg_dump</application>によるダンプよりバックアップとリストアが概してより速く行われます。
（同時に<application>pg_dump</application>のダンプより大きくなるので、場合によっては速度による利点が打ち消されるかもしれません。）
     </para>

     <para>
<!--
      As with base backups, the easiest way to produce a standalone
      hot backup is to use the <xref linkend="app-pgbasebackup"/>
      tool. If you include the <literal>-X</literal> parameter when calling
      it, all the write-ahead log required to use the backup will be
      included in the backup automatically, and no special action is
      required to restore the backup.
-->
ベースバックアップと同様に、スタンドアローンホットバックアップを作成する最も簡単な方法は <xref linkend="app-pgbasebackup"/>ツールを使用する方法です。
実行時に<literal>-X</literal>オプションをつけることでバックアップに必要な全ての先行書き込みログを自動的にバックアップに含めることができ、リストアするときには特に特別な作業を行う必要がありません。
     </para>
    </sect3>

    <sect3 id="compressed-archive-logs">
<!--
     <title>Compressed Archive Logs</title>
-->
     <title>圧縮アーカイブログ</title>

     <para>
<!--
      If archive storage size is a concern, you can use
      <application>gzip</application> to compress the archive files:
-->
もし、アーカイブのストレージ容量に懸念がある場合、アーカイブファイルを圧縮するために<application>gzip</application>を使用することもできます。
<programlisting>
archive_command = 'gzip &lt; %p &gt; /mnt/server/archivedir/%f.gz'
</programlisting>
<!--
      You will then need to use <application>gunzip</application> during recovery:
-->
復旧時は <application>gunzip</application>を使う必要があります。
<programlisting>
restore_command = 'gunzip &lt; /mnt/server/archivedir/%f.gz &gt; %p'
</programlisting>
     </para>
    </sect3>

    <sect3 id="backup-scripts">
<!--
     <title><varname>archive_command</varname> Scripts</title>
-->
     <title><varname>archive_command</varname>スクリプト</title>

     <para>
<!--
      Many people choose to use scripts to define their
      <varname>archive_command</varname>, so that their
      <filename>postgresql.conf</filename> entry looks very simple:
-->
<filename>postgresql.conf</filename>の記入事項が以下のように簡素となるため、多くの人が<varname>archive_command</varname>の定義にスクリプトの使用を選択します。
<programlisting>
archive_command = 'local_backup_script.sh "%p" "%f"'
</programlisting>
<!--
      Using a separate script file is advisable any time you want to use
      more than a single command in the archiving process.
      This allows all complexity to be managed within the script, which
      can be written in a popular scripting language such as
      <application>bash</application> or <application>perl</application>.
-->
アーカイブ処理手順において単一ではなくそれ以上の数のコマンドを使用したい場合はいつでも、別のスクリプトファイルの使用が推奨されます。
そうするとスクリプト内で全ての複雑性が管理されます。
スクリプトは<application>bash</application>または<application>perl</application>のようなよくあるスクリプト言語で記載できます。
     </para>

     <para>
<!--
      Examples of requirements that might be solved within a script include:
-->
スクリプト内で解決される要件の例として以下があります。
      <itemizedlist>
       <listitem>
        <para>
<!--
         Copying data to secure off-site data storage
-->
セキュアなオフサイトデータストレージへのデータのコピー
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         Batching WAL files so that they are transferred every three hours,
         rather than one at a time
-->
一回に全てではなく３時間毎に転送されるようにWALファイルのバッチ
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         Interfacing with other backup and recovery software
-->
その他のバックアップとリカバリのソフトウェアとのインタフェース
        </para>
       </listitem>
       <listitem>
        <para>
<!--
         Interfacing with monitoring software to report errors
-->
エラー報告を行う監視ソフトとのインタフェース
        </para>
       </listitem>
      </itemizedlist>
     </para>

     <tip>
      <para>
<!--
       When using an <varname>archive_command</varname> script, it's desirable
       to enable <xref linkend="guc-logging-collector"/>.
       Any messages written to <systemitem>stderr</systemitem> from the script will then
       appear in the database server log, allowing complex configurations to
       be diagnosed easily if they fail.
-->
<varname>archive_command</varname>スクリプトを使うときは<xref linkend="guc-logging-collector"/>を使えるようにすることが望ましい方法です。
そのスクリプトが<systemitem>stderr</systemitem>に書き出したメッセージはすべて、データベースのサーバーログとして書かれます。
このため複雑な設定でエラーが発生した時に、簡単に原因を突き止められます。
      </para>
     </tip>
    </sect3>
  </sect2>

  <sect2 id="continuous-archiving-caveats">
<!--
   <title>Caveats</title>
-->
   <title>警告</title>

   <para>
<!--
    At this writing, there are several limitations of the continuous archiving
    technique.  These will probably be fixed in future releases:
-->
本ドキュメント作成時点では、継続的アーカイブ技術にいくつかの制限があります。
将来のリリースでは修正されるはずです。

  <itemizedlist>
   <listitem>
    <para>
<!--
     If a <link linkend="sql-createdatabase"><command>CREATE DATABASE</command></link>
     command is executed while a base backup is being taken, and then
     the template database that the <command>CREATE DATABASE</command> copied
     is modified while the base backup is still in progress, it is
     possible that recovery will cause those modifications to be
     propagated into the created database as well.  This is of course
     undesirable.  To avoid this risk, it is best not to modify any
     template databases while taking a base backup.
-->
もしもベースバックアップが行われている時、<link linkend="sql-createdatabase"><command>CREATE DATABASE</command></link>コマンドが実行され、ベースバックアップが処理を実行している期間に<command>CREATE DATABASE</command>がコピーしているtemplateデータベースが変更されると、復旧処理はこれらの変更を作成されたデータベースにも同時に伝播させることは確実です。
もちろん、これは望まれる事ではありません。
この危険を回避するには、ベースバックアップ期間中にはすべてのtemplateデータベースを変更しないことが一番です。
    </para>
   </listitem>

   <listitem>
    <para>
<!--
     <link linkend="sql-createtablespace"><command>CREATE TABLESPACE</command></link>
     commands are WAL-logged with the literal absolute path, and will
     therefore be replayed as tablespace creations with the same
     absolute path.  This might be undesirable if the log is being
     replayed on a different machine.  It can be dangerous even if the
     log is being replayed on the same machine, but into a new data
     directory: the replay will still overwrite the contents of the
     original tablespace.  To avoid potential gotchas of this sort,
     the best practice is to take a new base backup after creating or
     dropping tablespaces.
-->
<link linkend="sql-createtablespace"><command>CREATE TABLESPACE</command></link>コマンドはリテラルの絶対パス付でWALにログが記録され、したがって、同じ絶対パスでのテーブル空間作成の時に再生されます。
これは、もしログが異なったマシン上で再生される場合には好ましくありません。
ログ再生がたとえ同一のマシンであっても、新規のデータディレクトリであれば危険です。
なぜなら、再生は元のテーブル空間の内容を上書きし続けるからです。
この種の潜在的な振舞いを防ぐためには、テーブル空間を作成もしくは削除後に新規ベースバックアップを行うのが最良の手段です。
    </para>
   </listitem>
  </itemizedlist>
   </para>

   <para>
<!--
    It should also be noted that the default <acronym>WAL</acronym>
    format is fairly bulky since it includes many disk page snapshots.
    These page snapshots are designed to support crash recovery, since
    we might need to fix partially-written disk pages.  Depending on
    your system hardware and software, the risk of partial writes might
    be small enough to ignore, in which case you can significantly
    reduce the total volume of archived logs by turning off page
    snapshots using the <xref linkend="guc-full-page-writes"/>
    parameter.  (Read the notes and warnings in <xref linkend="wal"/>
    before you do so.)  Turning off page snapshots does not prevent
    use of the logs for PITR operations.  An area for future
    development is to compress archived WAL data by removing
    unnecessary page copies even when <varname>full_page_writes</varname> is
    on.  In the meantime, administrators might wish to reduce the number
    of page snapshots included in WAL by increasing the checkpoint
    interval parameters as much as feasible.
-->
また、デフォルトの<acronym>WAL</acronym>フォーマットは数多くのディスクページのスナップショットを含んでいるため、かなりかさばるものになってしまっていることに触れておくべきでしょう。
これらのページスナップショットは、クラッシュから回復のために設計されています。
それというのも、回復処理の際には不完全に書き込まれているディスクページを修復しなければならないことがあるからです。
システムのハードウェアやソフトウェアによっては、不完全なディスクページの書き込みが起きてしまう危険性は無視してもよい程微小です。
この場合<xref linkend="guc-full-page-writes"/>パラメータを設定してページスナップショットを無効にすることで、アーカイブされたログの総容量を大幅に縮小できます
（実際に設定を行う前に、<xref linkend="wal"/>の注意事項と警告を読んでください）。
ページスナップショットを無効にしても PITR処理の際にログが使用できなくなることはありません。
将来の課題は、<varname>full_page_writes</varname>がたとえオンになっている場合であっても不要なページを取り除き、アーカイブ済みWALデータの圧縮を行うことでしょう。
差し当たり管理者は、可能な限りチェックポイント間隔パラメータを大きくすることによって、WALに含まれるページスナップショットの数を削減することができます。
   </para>
  </sect2>
 </sect1>

</chapter>
